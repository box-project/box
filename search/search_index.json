{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":".md-typeset h1, .md-content__button { display: none; } Goal The Box application simplifies the PHAR building process. Out of the box (no pun intended), the application can do many great things: \u26a1 Fast application bundling \ud83d\udd28 PHAR isolation \u2699\ufe0f Zero configuration by default \ud83d\ude94 Requirements checker \ud83d\udea8 Friendly error logging experience \ud83d\udd0d Retrieve information about the PHAR extension or a PHAR file and its contents ( box info or box diff ) \ud83d\udd10\ufe0f Verify the signature of an existing PHAR ( box verify ) \ud83d\udcdd Use Git tags and short commit hashes for versioning \ud83d\udd75\ufe0f\ufe0f Get recommendations and warnings about regarding your configuration ( box validate ) \ud83d\udc33 Docker support ( box docker ) Docs Go do the documentation . Usage Creating a PHAR should be as simple as running box compile ( no config required! ). It will however assume some defaults that you might want to change. Box will by default be looking in order for the files box.json and box.json.dist in the current working directory. A basic configuration could be for example changing the PHAR permissions: { \"chmod\" : \"0700\" } You can then find more advanced configuration settings in [the configuration documentation][configuration]. For more information on which command or options is available, you can run: box help Contributing The project provides a Makefile in which the most common commands have been registered such as fixing the coding style or running the test. make Backward Compatibility Promise (BCP) The policy is for the major part following the same as Symfony's one . Note that the code marked as @private or @internal are excluded from the BCP. The text displayed by the commands (e.g. compile or info ) or the content of the error/exception messages are also not subject to the BCP. Credits Project originally created by: Kevin Herrera ( @kherge ) which has now been moved under the Humbug umbrella .","title":"Home"},{"location":"#goal","text":"The Box application simplifies the PHAR building process. Out of the box (no pun intended), the application can do many great things: \u26a1 Fast application bundling \ud83d\udd28 PHAR isolation \u2699\ufe0f Zero configuration by default \ud83d\ude94 Requirements checker \ud83d\udea8 Friendly error logging experience \ud83d\udd0d Retrieve information about the PHAR extension or a PHAR file and its contents ( box info or box diff ) \ud83d\udd10\ufe0f Verify the signature of an existing PHAR ( box verify ) \ud83d\udcdd Use Git tags and short commit hashes for versioning \ud83d\udd75\ufe0f\ufe0f Get recommendations and warnings about regarding your configuration ( box validate ) \ud83d\udc33 Docker support ( box docker )","title":"Goal"},{"location":"#docs","text":"Go do the documentation .","title":"Docs"},{"location":"#usage","text":"Creating a PHAR should be as simple as running box compile ( no config required! ). It will however assume some defaults that you might want to change. Box will by default be looking in order for the files box.json and box.json.dist in the current working directory. A basic configuration could be for example changing the PHAR permissions: { \"chmod\" : \"0700\" } You can then find more advanced configuration settings in [the configuration documentation][configuration]. For more information on which command or options is available, you can run: box help","title":"Usage"},{"location":"#contributing","text":"The project provides a Makefile in which the most common commands have been registered such as fixing the coding style or running the test. make","title":"Contributing"},{"location":"#backward-compatibility-promise-bcp","text":"The policy is for the major part following the same as Symfony's one . Note that the code marked as @private or @internal are excluded from the BCP. The text displayed by the commands (e.g. compile or info ) or the content of the error/exception messages are also not subject to the BCP.","title":"Backward Compatibility Promise (BCP)"},{"location":"#credits","text":"Project originally created by: Kevin Herrera ( @kherge ) which has now been moved under the Humbug umbrella .","title":"Credits"},{"location":"code-isolation/","text":"PHAR code isolation Why/Explanation Isolating the PHAR Debugging the scoping Why/Explanation When bundling the code in a PHAR, it is equivalent to compacting all the code in a single file. However unlike in a compiled language, the code does not change. This, when the PHAR loads external code, can lead to dependency conflicts. To illustrate that issue with an example: we are building a console application myapp.phar which relies on the library Symfony YAML 2.8.0 which execute a given PHP script. # Usage of the application we are building myapp.phar myscript.php For the sake of the example, myapp.phar is using Composer and loads the YAML component right away when starting, i.e. when running myapp.phar , the class Symfony\\Yaml\\Yaml from the PHAR is going to be loaded. Now what myapp.phar is actually going to do is scan the whole file given, and do some reflection work on each classes found. I.e. for each class $class found, it will do new \\ReflectionClass($class) . Now if myscript.php is using the Symfony YAML 4.0.0 component with some new features added in 4.0.0 that are non-existent in 2.8.0, when doing new \\ReflectionClass('Symfony\\Yaml\\Yaml') , the class Symfony\\Yaml\\Yaml will be loaded (yes, doing reflection on a class loads it!). BUT, it turns out the class Symfony\\Yaml\\Yaml is already loaded: not the 4.0.0 from myscript.php but the one from the PHAR ( 2.8.0 ). So any information you will get will be from the wrong class! Is this really an issue? The answer is it depends. Here as a few real life example where this is an issue: A static analysis tool like PHPStan A test framework like PHPUnit A quality analysis tool like SensioLabsInsight which executes arbitrary code (e.g. to check) that the application is booting A piece of code that can be mixed with any code, such as a Wordpress plugin Isolating the PHAR Box provides an integration with PHP-Scoper . To use it, enable the KevinGH\\Box\\Compactor\\PhpScoper compactor . If you need an extra configuration for PHP-Scoper, you can create a scoper.inc.php file as per the documentation . The only difference is that you can ignore the finders setting as the files to scope are already collected by Box. And that's it! Warning: keep in mind however that scoping is a very brittle process due to the nature of PHP. As such you will likely need some adjustments in your code or the configuration. Debugging the scoping As mentioned above, unless you have a very boring and predictable code (which is a good thing!), due to how dynamic PHP is, scoping will almost guaranteed never work on the first and will require adjustments. To help with the process, there is two recommendations: Have an end-to-end test for your application. On in which you can easily swap from your regular binary, the PHAR and the isolated PHAR. This will help to identify at which test there is an issue besides being able to easily guarantee your application, shipped as a PHAR or not, is somewhat working. Make use of Box --debug option in the compile command. It dumps the code added to the PHAR in a .box-dump directory. This allows you to more easily inspect, alter and test the code shipped in the PHAR. This way, you can make sure the code shipped is working before worrying about whether that code is going to work inside a PHAR. Use the process command on a specific file to check the result and the effects of the configuration on it \u00ab Optimize your PHAR \u2022 Docker support \u00bb","title":"PHAR code isolation"},{"location":"code-isolation/#phar-code-isolation","text":"Why/Explanation Isolating the PHAR Debugging the scoping","title":"PHAR code isolation"},{"location":"code-isolation/#whyexplanation","text":"When bundling the code in a PHAR, it is equivalent to compacting all the code in a single file. However unlike in a compiled language, the code does not change. This, when the PHAR loads external code, can lead to dependency conflicts. To illustrate that issue with an example: we are building a console application myapp.phar which relies on the library Symfony YAML 2.8.0 which execute a given PHP script. # Usage of the application we are building myapp.phar myscript.php For the sake of the example, myapp.phar is using Composer and loads the YAML component right away when starting, i.e. when running myapp.phar , the class Symfony\\Yaml\\Yaml from the PHAR is going to be loaded. Now what myapp.phar is actually going to do is scan the whole file given, and do some reflection work on each classes found. I.e. for each class $class found, it will do new \\ReflectionClass($class) . Now if myscript.php is using the Symfony YAML 4.0.0 component with some new features added in 4.0.0 that are non-existent in 2.8.0, when doing new \\ReflectionClass('Symfony\\Yaml\\Yaml') , the class Symfony\\Yaml\\Yaml will be loaded (yes, doing reflection on a class loads it!). BUT, it turns out the class Symfony\\Yaml\\Yaml is already loaded: not the 4.0.0 from myscript.php but the one from the PHAR ( 2.8.0 ). So any information you will get will be from the wrong class! Is this really an issue? The answer is it depends. Here as a few real life example where this is an issue: A static analysis tool like PHPStan A test framework like PHPUnit A quality analysis tool like SensioLabsInsight which executes arbitrary code (e.g. to check) that the application is booting A piece of code that can be mixed with any code, such as a Wordpress plugin","title":"Why/Explanation"},{"location":"code-isolation/#isolating-the-phar","text":"Box provides an integration with PHP-Scoper . To use it, enable the KevinGH\\Box\\Compactor\\PhpScoper compactor . If you need an extra configuration for PHP-Scoper, you can create a scoper.inc.php file as per the documentation . The only difference is that you can ignore the finders setting as the files to scope are already collected by Box. And that's it! Warning: keep in mind however that scoping is a very brittle process due to the nature of PHP. As such you will likely need some adjustments in your code or the configuration.","title":"Isolating the PHAR"},{"location":"code-isolation/#debugging-the-scoping","text":"As mentioned above, unless you have a very boring and predictable code (which is a good thing!), due to how dynamic PHP is, scoping will almost guaranteed never work on the first and will require adjustments. To help with the process, there is two recommendations: Have an end-to-end test for your application. On in which you can easily swap from your regular binary, the PHAR and the isolated PHAR. This will help to identify at which test there is an issue besides being able to easily guarantee your application, shipped as a PHAR or not, is somewhat working. Make use of Box --debug option in the compile command. It dumps the code added to the PHAR in a .box-dump directory. This allows you to more easily inspect, alter and test the code shipped in the PHAR. This way, you can make sure the code shipped is working before worrying about whether that code is going to work inside a PHAR. Use the process command on a specific file to check the result and the effects of the configuration on it \u00ab Optimize your PHAR \u2022 Docker support \u00bb","title":"Debugging the scoping"},{"location":"configuration/","text":"Configuration Base path Main Output Permissions Check requirements Including files Force auto-discovery ( force-autodiscovery ) Files ( files and files-bin ) Directories ( directories and directories-bin ) Finder ( finder and finder-bin ) Blacklist ( blacklist ) Excluding the Composer files ( exclude-composer-files ) Excluding dev files ( exclude-dev-files ) Map ( map ) Stub Stub ( stub ) Alias ( alias ) Shebang ( shebang ) Banner ( banner ) Banner file ( banner-file ) Dumping the Composer autoloader ( dump-autoload ) Compactors ( compactors ) Annotations ( annotations ) PHP-Scoper ( php-scoper ) Compression algorithm ( compression ) Security Signing algorithm ( algorithm ) The private key ( key ) The private key password ( key-pass ) Metadata ( metadata ) Replaceable placeholders Replacements ( replacements ) Replacement sigil ( replacement-sigil ) Datetime placeholder ( datetime ) Datetime placeholder format ( datetime-format ) Pretty git commit placeholder ( git ) Git commit placeholder ( git-commit ) Short git commit placeholder ( git-commit-short ) Git tag placeholder ( git-tag ) Git version placeholder ( git-version ) The build command will build a new PHAR based on a variety of settings. This command relies on a configuration file for loading PHAR packaging settings. If a configuration file is not specified through the --config|-c option , one of the following files will be used (in order): box.json , box.json.dist . If no configuration file is found, Box will proceed with the default settings. The configuration file is a JSON object saved to a file. Note that all settings are optional . If a setting is set to null , then its default value will be picked and is strictly equivalent to not setting the value. { \"algorithm\" : \"?\" , \"alias\" : \"?\" , \"annotations\" : \"?\" , \"banner\" : \"?\" , \"banner-file\" : \"?\" , \"base-path\" : \"?\" , \"blacklist\" : \"?\" , \"check-requirements\" : \"?\" , \"chmod\" : \"?\" , \"compactors\" : \"?\" , \"compression\" : \"?\" , \"datetime\" : \"?\" , \"datetime-format\" : \"?\" , \"directories\" : \"?\" , \"directories-bin\" : \"?\" , \"dump-autoload\" : \"?\" , \"exclude-composer-files\" : \"?\" , \"exclude-dev-files\" : \"?\" , \"files\" : \"?\" , \"files-bin\" : \"?\" , \"finder\" : \"?\" , \"finder-bin\" : \"?\" , \"force-autodiscovery\" : \"?\" , \"git\" : \"?\" , \"git-commit\" : \"?\" , \"git-commit-short\" : \"?\" , \"git-tag\" : \"?\" , \"git-version\" : \"?\" , \"intercept\" : \"?\" , \"key\" : \"?\" , \"key-pass\" : \"?\" , \"main\" : \"?\" , \"map\" : \"?\" , \"metadata\" : \"?\" , \"output\" : \"?\" , \"php-scoper\" : \"?\" , \"replacement-sigil\" : \"?\" , \"replacements\" : \"?\" , \"shebang\" : \"?\" , \"stub\" : \"?\" } Base-path ( base-path ) The base-path ( string | null ) setting is used to specify where all of the relative file paths should resolve to. This does not, however, alter where the built PHAR will be stored (see: output ). If set to null or not specified, the base path used is the directory containing the configuration file when a specific configuration file is given or the current working directory otherwise. Main ( main ) The main ( string | false | null ) setting is used to specify the file (relative to base-path ) that will be run when the PHAR is executed from the command line (To not confuse with the stub which is the PHAR bootstrapping file). When you have a main script file that can be used as a stub , you can disable the main script by setting it to false: { \"stub\" : \"bin/acme.php\" , \"main\" : false } When the parameter is not given or set to null , Box tries to guess the binary of the application with the composer.json file. If the Composer bin is set, Box will pick the first value provided. Otherwise it will fallback on the PHAR default file used which is index.php . The main file contents is processed by the compactors as the other files. If the main file starts with a shebang line ( #! ), it will be automatically removed (the shebang line goes in the stub for a PHAR and is configured by the shebang setting). Output ( output ) The output ( string | null ) setting specifies the file name and path of the newly built PHAR. If the value of the setting is not an absolute path, the path will be relative to the base path. If not provided or set to null , the default value used will based on the main . For example if the main file is bin/acme.php or bin/acme then the output will be bin/acme.phar . Permissions ( chmod ) The chmod ( string | null ) setting is used to change the file permissions of the newly built PHAR. The string contains an octal value e.g. 0750 . By default the permissions of the created PHAR are unchanged so it should be 0644 . Check the following link for more on the possible values. Check requirements ( check-requirements ) The check requirements setting ( boolean | null , default true ) is used to allow the PHAR to check for the application constraint before running. See more information about it here . If not set or set to null , then the requirement checker will be added. Note that this is true only if either the composer.json or composer.lock could have been found. Warning this check is still done within the PHAR. As a result, if the required extension to open the PHAR due to the compression algorithm is not loaded, a hard failure will still appear: the requirement checker cannot be executed before that. Including files There is two ways to include files. The first one is to not be picky about which files are shipped in the PHAR. If you omit any of the following options, all the files found. The base directory used to find the files is either the configuration file if one is used/specified or the current working directory otherwise. The blacklist setting can be used to filter out some files from that selection. If you however want a more granular selection, you can use a combination of the following options: files , files-bin , directories , directories-bin , finder , finder-bin , blacklist . If directories or finder is set (this includes empty values), Box will no longer try to guess which files should be included or not (unless you force the auto-discovery ) and will give you full control on it instead. Note By default, dev dependencies are excluded for both strategies. However if you still which to include a file or directory from a dev dependency, you can do so by adding it via one of the following setting: files , files-bin , directories or directories-bin . Warning binary files are added before regular files. As a result if a file is found in both regular files and binary files, the regular file will take precedence. Force auto-discovery ( force-autodiscovery ) The force-autodiscovery ( bool default false ) setting forces Box to attempt to find which files to include even though you are using the directories or finder setting. When Box tries to find which files to include, it may remove some files such as readmes or test files. If however you are using the directories or finder , Box will append the found files to the ones you listed. Files ( files and files-bin ) The files ( string[] | null default [] ) setting is a list of files paths relative to base-path unless absolute. Each file will be processed by the compactors , have their placeholder values replaced (see: replacements ) and added to the PHAR. This setting is not affected by the blacklist setting. files-bin is analogue to files except the files are added to the PHAR unmodified. This is suitable for the files such as images, those that contain binary data or simply a file you do not want to alter at all despite using compactors . Warning Symlinks are not followed/supported. Directories ( directories and directories-bin ) The directories ( string[] | null default [] ) setting is a list of directory paths relative to base-path . All files will be processed by the compactors , have their placeholder values replaced (see: replacements ) and added to the PHAR. Files listed in the blacklist will not be added to the PHAR. directories-bin is analogue to directories except the files are added to the PHAR unmodified. This is suitable for the files such as images, those that contain binary data or simply a file you do not want to alter at all despite using compactors. Warning Setting the key directories (regardless of its value), will disable the file auto-discovery. If you want to keep it, check the force the auto-discovery setting. Warning By default Box excludes some files (e.g. dot files, readmes & co). This is done in order to attempt to reduce the final PHAR size. There is at the moment no way to disable this (maybe this could be done via a new setting) but it remains possible to include them via files , files-bin , directories-bin or your own finder or finder-bin . Warning Symlinks are not followed/supported. Finder ( finder and finder-bin ) The finder ( object[] | null default [] ) setting is a list of JSON objects. Each object (key, value) tuple is a (method, arguments) of the Symfony Finder used by Box. If an array of values is provided for a single key, the method will be called once per value in the array. Note that the paths specified for the in method are relative to base-path and that the finder will account for the files registered in the blacklist . finder-bin is analogue to finder except the files are added to the PHAR unmodified. This is suitable for the files such as images, those that contain binary data or simply a file you do not want to alter at all despite using compactors . Warning Setting the key finder (regardless of its value), will disable the file auto-discovery. If you want to keep it, check the force the auto-discovery setting. Warning Symlinks are not followed/supported. Example: { \"finder\" : [ { \"notName\" : \"/LICENSE|.*\\\\.md|.*\\\\.dist|Makefile|composer\\\\.json|composer\\\\.lock/\" , \"exclude\" : [ \"doc\" , \"test\" , \"test_old\" , \"tests\" , \"Tests\" , \"vendor-bin\" ], \"in\" : \"vendor\" }, { \"name\" : \"composer.json\" , \"in\" : \".\" } ] } Blacklist ( blacklist ) The blacklist ( string[] | null default [] ) setting is a list of files that must not be added. The files blacklisted are the ones found using the other available configuration settings: files , files-bin , directories , directories-bin , finder , finder-bin . Note that all the blacklisted paths are relative to the settings configured above. For example if you have the following file structure: project/ \u251c\u2500\u2500 box.json.dist \u251c\u2500\u2500 A/ | \u251c\u2500\u2500 A00 | \u2514\u2500\u2500 A01 \u2514\u2500\u2500 B/ \u251c\u2500\u2500 B00 \u251c\u2500\u2500 B01 \u2514\u2500\u2500 A/ \u2514\u2500\u2500 BA00 With: { # o t her n o n f ile rela te d se tt i n gs \"blacklist\" : [ \"A\" ] } Box will try to collect all the files found in project (cf. Including files ) but will exclude A/ and `B/A resulting in the following files being collected: project/ \u251c\u2500\u2500 box.json.dist \u2514\u2500\u2500 B/ \u251c\u2500\u2500 B00 \u2514\u2500\u2500 B01 If you want a more granular blacklist leverage, use the Finders configuration instead. Excluding the Composer files ( exclude-composer-files ) The exclude-composer-files ( boolean | null , default true ) setting will result in removing the Composer files composer.json , composer.lock and vendor/composer/installed.json if they are found regardless of whether or not they were found by Box alone or explicitly included. Excluding dev files ( exclude-dev-files ) The exclude-dev-files ( bool default true ) setting will, when enabled, cause Box to attempt to exclude the files belonging to dev only packages. For example for the given project: composer.json { \"require\" : { \"beberlei/assert\" : \"^3.0\" }, \"require-dev\" : { \"bamarni/composer-bin-plugin\" : \"^1.2\" } } The vendor directory will have beberlei/assert and bamarni/composer-bin-plugin . If exclude-dev-files is not disabled, the bamarni/composer-bin-plugin package will be removed from the PHAR. This setting will automatically be disabled when dump-autoload is disabled. Indeed, otherwise some files will not be shipped in the PHAR but may still appear in the Composer autoload classmap, resulting in an autoloading error. Map ( map ) The map ( object[] default [] ) setting is used to change where some (or all) files are stored inside the PHAR. The key is a beginning of the relative path that will be matched against the file being added to the PHAR. If the key is a match, the matched segment will be replaced with the value. If the key is empty, the value will be prefixed to all paths (except for those already matched by an earlier key). For example, with the following configuration excerpt: { \"map\" : [ { \"my/test/path\" : \"src/Test\" }, { \"\" : \"src/Another\" } ] } with the following files added to the PHAR: my/test/path/file.php my/test/path/some/other.php my/test/another.php the above files will be stored with the following paths in the PHAR: src/Test/file.php src/Test/some/other.php src/Another/my/test/another.php Stub The PHAR stub file is the PHAR bootstrapping file, i.e. the very first file executed whenever the PHAR is executed. It usually contains things like the PHAR configuration and executing the main script file . The default PHAR stub file can be used but Box also propose a couple of options to customize the stub used. Stub ( stub ) The stub ( string | boolean | null default true ) setting is used to specify the location of a stub file or if one should be generated: - string : Path to the stub file will be used as is inside the PHAR - true (default): A new stub will be generated - false : The default stub used by the PHAR class will be used If a custom stub file is provided, none of the other options ( shebang , [ intercept ][intercept] and alias ) are used. Shebang ( shebang ) The shebang ( string | false | null ) setting is used to specify the shebang line used when generating a new stub. By default, this line is used: #!/usr/bin/env php The shebang line can be removed altogether if set to false . Intercept ( intercept ) The intercept ( boolean | null default false ) setting is used when generating a new stub. If setting is set to true , the Phar::interceptFileFuncs() method will be called in the stub. Alias ( alias ) The alias ( string | null ) setting is used when generating a new stub to call the Phar::mapPhar() . This makes it easier to refer to files in the PHAR and ensure the access to internal files will always work regardless of the location of the PHAR on the file system. If no alias is provided, a generated unique name will be used for it in order to map the main file . Note that this may have undesirable effects if you are using the generated stub Example: // .phar.stub #!/usr/bin/env php <?php if ( class_exists ( 'Phar' )) { Phar :: mapPhar ( 'alias.phar' ); require 'phar://' . __FILE__ . '/index.php' ; } __HALT_COMPILER (); ?> // index.php <?php if ( ! isset ( $GLOBALS [ 'EXECUTE' ])) { $GLOBALS [ 'EXECUTE' ] = true ; } // On the first execution, we require that other file while // on the second we will echo \"Hello world!\" if ( $GLOBALS [ 'EXECUTE' ]) { require 'foo.php' ; } else { echo 'Hello world!' ; } // foo.php <? php $GLOBALS [ 'EXECUTE' ] = false ; // Notice how we are using `phar://alias.phar` here. This will // always work. This allows you to not have to find where the file // is located in the PHAR neither finding the PHAR file path require 'phar://alias.phar/index.php' ; If you are using the default stub, Phar::setAlias() will be used. Note however that this will behave slightly differently. Example: <?php $phar = new Phar ( 'index.phar' ); // Warning: creating a Phar instance results in *loading* the file. From this point, the // PHAR stub file has been loaded and as a result, if the PHAR had an alias the alias // will be registered. $phar -> setAlias ( 'foo.phar' ); $phar -> addFile ( 'LICENSE' ); file_get_contents ( 'phar://foo.phar/LICENSE' ); // Will work both inside the PHAR but as well as outside as soon as the // PHAR is loaded in-memory. As you can see above, loading a PHAR which has an alias result in a non-negligible side effect. A typical case where this might be an issue can be illustrated with box itself. For its end-to-end test, the process is along the lines of: Build a PHAR box.phar from the source code Build the PHAR box.phar from the source again but using the previous PHAR this time If an alias box-alias.phar was registered for both for example, the building would fail. Indeed when building the second PHAR, the first PHAR is loaded which loads the alias box-alias.phar . When creating the second PHAR, box would try to register the alias box-alias.phar to that new PHAR but as the alias is already used, an error will be thrown. Banner ( banner ) The banner ( string | string[] | false | null ) setting is the banner comment that will be used when a new stub is generated. The value of this setting must not already be enclosed within a comment block as it will be automatically done for you. For example Custom banner will result in the stub file: /* * Custom banner */ An array of strings can be used for multilines banner: { \"banner\" : [ \"This file is part of the box project.\" , \"\" , \"(c) Kevin Herrera <kevin@herrera.io>\" , \"Th\u00e9o Fidry <theo.fidry@gmail.com>\" , \"\" , \"This source file is subject to the MIT license that is bundled\" , \"with this source code in the file LICENSE.\" ] } Will result in: /* * This file is part of the box project. * * (c) Kevin Herrera <kevin@herrera.io> * Th\u00e9o Fidry <theo.fidry@gmail.com> * * This source file is subject to the MIT license that is bundled * with this source code in the file LICENSE. */ By default, the Box banner is used. If set to false , no banner at all will be used. The content of this value is discarded if banner-file is set. Banner file ( banner-file ) The banner-file ( string | null ignored by default) setting is like banner, except it is a path (relative to the base path ) to the file that will contain the comment. Like banner, the comment must not already be enclosed in a comment block. If this parameter is set to a different value than null , then the value of banner will be discarded. Dumping the Composer autoloader ( dump-autoload ) The dump-autoload ( boolean | null , default true ) setting will result in Box dump the Composer autoload with the classmap authoritative mode and the --no-dev option which disables the autoload-dev rules. This is however done only if a composer.json file could be found. If a composer.lock file is found as well, the file vendor/composer/installed.json will be required too. The dumping of the autoloader will be ignored if the composer.json file could not be found. The autoloader is dumped at the end of the process to ensure it will take into account the eventual modifications done by the compactors process. Compactors ( compactors ) The compactors ( string[] | null default [] ) setting is a list of file contents compacting classes that must be registered. A file compacting class is used to reduce the size of a specific file type. The following is a simple example: <?php namespace Acme ; use KevinGH\\Box\\Compactor\\Compactor ; class MyCompactor implements Compactor { /** * {@inheritdoc} */ public function compact ( string $file , string $contents ) : string { if ( preg_match ( '/\\.txt/' , \\ $file )) { return trim ( $contents ); } return $contents ; } } The following compactors are included with Box: KevinGH\\Box\\Compactor\\Json : compress JSON files KevinGH\\Box\\Compactor\\Php : strip down classes from phpdocs & comments KevinGH\\Box\\Compactor\\PhpScoper : isolate the code using PHP-Scoper The effects of the compactors and replacement values can be tested with the process command \u2728. Annotations ( annotations ) The annotations ( boolean | object | null default true ) setting is used to enable compacting annotations in PHP source code. This setting is only taken into consideration if the KevinGH\\Box\\Compactor\\Php compactor is enabled. By default, it removes all non real-like annotations from the PHP code. See the following example: Original code <?php /** * Function comparing the two given values * * @param int $x * @param int $y * * @return int * * @author Th\u00e9o Fidry * @LICENSE MIT * * @Acme(type = \"function\") */ function foo ( $x , $y ) : int { // Compare the two values return $x <=> $y ; } Compacted code <?php /** @Acme(type=\"function\") */ function foo ( $x , $y ) : int { return $x <=> $y ; } Note that the empty line returns are on purpose: it is to keep the same line number for the files between your source code and the code bundled in the PHAR. If you wish to keep all annotations, you can disable the annotations like so: { \"annotations\" : false } For a more granular list, you can manually configure the list of annotations you wish to ignore: { \"annotations\" : { \"ignore\" : [ \"author\" , \"package\" , \"version\" , \"see\" ] } } PHP-Scoper ( php-scoper ) The PHP-Scoper setting ( string | null default scoper.inc.php ) points to the path to the PHP-Scoper configuration file. For more documentation regarding PHP-Scoper, you can head to PHAR code isolation or PHP-Scoper official documentation . Note that this setting is used only if the compactor KevinGH\\Box\\Compactor\\PhpScoper is registered. Compression algorithm ( compression ) The compression ( string | null default NONE ) setting is the compression algorithm to use when the PHAR is built. The compression affects the individual files within the PHAR and not the PHAR as a whole ( Phar::compressFiles() ). The following is a list of the signature algorithms available: GZ (the most efficient most of the time) BZ2 NONE (default) Warning Be aware that if compressed, the PHAR will required the appropriate extension ( zlib for GZ and bz2 for BZ2 ) to execute the PHAR. Without it, PHP will not be able to open the PHAR at all. Security Signing algorithm ( algorithm ) The algorithm ( string | null default SHA1 ) setting is the signing algorithm to use when the PHAR is built ( Phar::setSignatureAlgorithm() ). The following is a list of the signature algorithms available: MD5 SHA1 SHA256 SHA512 OPENSSL By default PHARs are SHA1 signed. The OPENSSL algorithm will require to provide a key . The private key ( key ) The key ( string | null default null ) setting is used to specify the path to the private key file. The private key file will be used to sign the PHAR using the OPENSSL signature algorithm (see Signing algorithm ) and the setting will be completely ignored otherwise. If an absolute path is not provided, the path will be relative to the current working directory. The private key password ( key-pass ) The private key password ( string | boolean | null default null ) setting is used to specify the pass-phrase for the private key. If a string is provided, it will be used as is as the pass-phrase. If true is provided, you will be prompted for the passphrase unless you are not in an interactive environment. This setting will be ignored if no key has been provided. Metadata ( metadata ) The metadata ( any default none) setting can be any value. This value will be stored as metadata that can be retrieved from the built PHAR ( Phar::getMetadata() ). If you specify a callable (as a string), it will be evaluated without any arguments. For example, if you take the following code: <?php # callable_script.php class MyCallbacks { public static function generateMetadata () { return [ 'application_version' => '1.0.0-dev' ]; } } With the configuration excerpt: { \"metadata\" : \"MyCallbacks::generateMetadata\" } Then the Phar::getMetadata() will return ['application_version' => '1.0.0-dev'] array. CAUTION : Your callable function must be readable by your autoloader. That means, for Composer, in previous example, we require to have such kind of declaration in your composer.json file. { \"autoload\" : { \"files\" : [ \"/path/to/your/callable_script.php\" ] } } Replaceable placeholders This feature allows you to set placeholders in your code which will be replaced by different values by Box when building the PHAR. For example, if you take the following code: <?php class Application { public function getVersion () : string { return '@git_commit_short@' ; } } With the configuration excerpt: { \"git-commit-short\" : \"git_commit_short\" } Then the actual code shipped in the PHAR will be: <?php class Application { public function getVersion () : string { return 'a6c5d93' ; } } The @ is the default value of the sigil which is the placeholders delimited and git-commit-short is one of the built in placeholder. Box ships a few buit-in placeholders which you can find bellow, but you can also specify any replacement value via the replacements setting . The effects of the compactors and replacement values can be tested with the process command \u2728. Replacements ( replacements ) The replacements ( object | null , default {} ) setting is a map of placeholders (as keys) and their values. The placeholders are replaced in all non-binary files with the specified values. For example: { \"replacements\" : { \"foo\" : \"bar\" } } Will result in the string @foo@ in your code to be replaced by 'bar' . The delimiter @ being the sigil . Replacement sigil ( replacement-sigil ) The replacement sigil ( string | null default @ ) is the character or chain of characters used to delimit the placeholders. See the @ replacements setting for examples of placeholders. Datetime placeholder ( datetime ) The datetime ( string | null default null ) setting is the name of a placeholder value that will be replaced in all non-binary files by the current datetime. If no value is given ( null ) then this placeholder will be ignored. Example value the placeholder will be replaced with: 2015-01-28 14:55:23 CEST The format of the date used is defined by the datetime-format setting . Datetime placeholder format ( datetime-format ) The datetime format placeholder ( string | null , default Y-m-d H:i:s T ) setting accepts a valid PHP date format . It can be used to change the format for the datetime setting. Pretty git tag placeholder ( git ) The git tag placeholder ( string | null default null ) setting is the name of a placeholder value that will be replaced in all non-binary files by the current git tag of the repository. Example of value the placeholder will be replaced with: 2.0.0 on an exact tag match 2.0.0@e558e33 on a commit following a tag Git commit placeholder ( git-commit ) The git commit ( string | null default null ) setting is the name of a placeholder value that will be replaced in all non-binary files by the current git commit hash of the repository. Example of value the placeholder will be replaced with: e558e335f1d165bc24d43fdf903cdadd3c3cbd03 Short git commit placeholder ( git-commit-short ) The short git commit ( string | null default null ) setting is the name of a placeholder value that will be replaced in all non-binary files by the current git short commit hash of the repository. Example of value the placeholder will be replaced with: e558e33 Git tag placeholder ( git-tag ) The git tag placeholder ( string | null default null ) setting is the name of a placeholder value that will be replaced in all non-binary files by the current git tag of the repository. Example of value the placeholder will be replaced with: 2.0.0 on an exact tag match 2.0.0-2-ge558e33 on a commit following a tag Git version placeholder ( git-version ) The git version ( string | null default null ) setting is the name of a placeholder value that will be replaced in all non-binary files by the one of the following (in order): The git repository's most recent tag. The git repository's current short commit hash. The short commit hash will only be used if no tag is available. \u00ab Installation \u2022 Requirement Checker \u00bb","title":"Configuration"},{"location":"configuration/#configuration","text":"Base path Main Output Permissions Check requirements Including files Force auto-discovery ( force-autodiscovery ) Files ( files and files-bin ) Directories ( directories and directories-bin ) Finder ( finder and finder-bin ) Blacklist ( blacklist ) Excluding the Composer files ( exclude-composer-files ) Excluding dev files ( exclude-dev-files ) Map ( map ) Stub Stub ( stub ) Alias ( alias ) Shebang ( shebang ) Banner ( banner ) Banner file ( banner-file ) Dumping the Composer autoloader ( dump-autoload ) Compactors ( compactors ) Annotations ( annotations ) PHP-Scoper ( php-scoper ) Compression algorithm ( compression ) Security Signing algorithm ( algorithm ) The private key ( key ) The private key password ( key-pass ) Metadata ( metadata ) Replaceable placeholders Replacements ( replacements ) Replacement sigil ( replacement-sigil ) Datetime placeholder ( datetime ) Datetime placeholder format ( datetime-format ) Pretty git commit placeholder ( git ) Git commit placeholder ( git-commit ) Short git commit placeholder ( git-commit-short ) Git tag placeholder ( git-tag ) Git version placeholder ( git-version ) The build command will build a new PHAR based on a variety of settings. This command relies on a configuration file for loading PHAR packaging settings. If a configuration file is not specified through the --config|-c option , one of the following files will be used (in order): box.json , box.json.dist . If no configuration file is found, Box will proceed with the default settings. The configuration file is a JSON object saved to a file. Note that all settings are optional . If a setting is set to null , then its default value will be picked and is strictly equivalent to not setting the value. { \"algorithm\" : \"?\" , \"alias\" : \"?\" , \"annotations\" : \"?\" , \"banner\" : \"?\" , \"banner-file\" : \"?\" , \"base-path\" : \"?\" , \"blacklist\" : \"?\" , \"check-requirements\" : \"?\" , \"chmod\" : \"?\" , \"compactors\" : \"?\" , \"compression\" : \"?\" , \"datetime\" : \"?\" , \"datetime-format\" : \"?\" , \"directories\" : \"?\" , \"directories-bin\" : \"?\" , \"dump-autoload\" : \"?\" , \"exclude-composer-files\" : \"?\" , \"exclude-dev-files\" : \"?\" , \"files\" : \"?\" , \"files-bin\" : \"?\" , \"finder\" : \"?\" , \"finder-bin\" : \"?\" , \"force-autodiscovery\" : \"?\" , \"git\" : \"?\" , \"git-commit\" : \"?\" , \"git-commit-short\" : \"?\" , \"git-tag\" : \"?\" , \"git-version\" : \"?\" , \"intercept\" : \"?\" , \"key\" : \"?\" , \"key-pass\" : \"?\" , \"main\" : \"?\" , \"map\" : \"?\" , \"metadata\" : \"?\" , \"output\" : \"?\" , \"php-scoper\" : \"?\" , \"replacement-sigil\" : \"?\" , \"replacements\" : \"?\" , \"shebang\" : \"?\" , \"stub\" : \"?\" }","title":"Configuration"},{"location":"configuration/#base-path-base-path","text":"The base-path ( string | null ) setting is used to specify where all of the relative file paths should resolve to. This does not, however, alter where the built PHAR will be stored (see: output ). If set to null or not specified, the base path used is the directory containing the configuration file when a specific configuration file is given or the current working directory otherwise.","title":"Base-path (base-path)"},{"location":"configuration/#main-main","text":"The main ( string | false | null ) setting is used to specify the file (relative to base-path ) that will be run when the PHAR is executed from the command line (To not confuse with the stub which is the PHAR bootstrapping file). When you have a main script file that can be used as a stub , you can disable the main script by setting it to false: { \"stub\" : \"bin/acme.php\" , \"main\" : false } When the parameter is not given or set to null , Box tries to guess the binary of the application with the composer.json file. If the Composer bin is set, Box will pick the first value provided. Otherwise it will fallback on the PHAR default file used which is index.php . The main file contents is processed by the compactors as the other files. If the main file starts with a shebang line ( #! ), it will be automatically removed (the shebang line goes in the stub for a PHAR and is configured by the shebang setting).","title":"Main (main)"},{"location":"configuration/#output-output","text":"The output ( string | null ) setting specifies the file name and path of the newly built PHAR. If the value of the setting is not an absolute path, the path will be relative to the base path. If not provided or set to null , the default value used will based on the main . For example if the main file is bin/acme.php or bin/acme then the output will be bin/acme.phar .","title":"Output (output)"},{"location":"configuration/#permissions-chmod","text":"The chmod ( string | null ) setting is used to change the file permissions of the newly built PHAR. The string contains an octal value e.g. 0750 . By default the permissions of the created PHAR are unchanged so it should be 0644 . Check the following link for more on the possible values.","title":"Permissions (chmod)"},{"location":"configuration/#check-requirements-check-requirements","text":"The check requirements setting ( boolean | null , default true ) is used to allow the PHAR to check for the application constraint before running. See more information about it here . If not set or set to null , then the requirement checker will be added. Note that this is true only if either the composer.json or composer.lock could have been found. Warning this check is still done within the PHAR. As a result, if the required extension to open the PHAR due to the compression algorithm is not loaded, a hard failure will still appear: the requirement checker cannot be executed before that.","title":"Check requirements (check-requirements)"},{"location":"configuration/#including-files","text":"There is two ways to include files. The first one is to not be picky about which files are shipped in the PHAR. If you omit any of the following options, all the files found. The base directory used to find the files is either the configuration file if one is used/specified or the current working directory otherwise. The blacklist setting can be used to filter out some files from that selection. If you however want a more granular selection, you can use a combination of the following options: files , files-bin , directories , directories-bin , finder , finder-bin , blacklist . If directories or finder is set (this includes empty values), Box will no longer try to guess which files should be included or not (unless you force the auto-discovery ) and will give you full control on it instead. Note By default, dev dependencies are excluded for both strategies. However if you still which to include a file or directory from a dev dependency, you can do so by adding it via one of the following setting: files , files-bin , directories or directories-bin . Warning binary files are added before regular files. As a result if a file is found in both regular files and binary files, the regular file will take precedence.","title":"Including files"},{"location":"configuration/#force-auto-discovery-force-autodiscovery","text":"The force-autodiscovery ( bool default false ) setting forces Box to attempt to find which files to include even though you are using the directories or finder setting. When Box tries to find which files to include, it may remove some files such as readmes or test files. If however you are using the directories or finder , Box will append the found files to the ones you listed.","title":"Force auto-discovery (force-autodiscovery)"},{"location":"configuration/#files-files-and-files-bin","text":"The files ( string[] | null default [] ) setting is a list of files paths relative to base-path unless absolute. Each file will be processed by the compactors , have their placeholder values replaced (see: replacements ) and added to the PHAR. This setting is not affected by the blacklist setting. files-bin is analogue to files except the files are added to the PHAR unmodified. This is suitable for the files such as images, those that contain binary data or simply a file you do not want to alter at all despite using compactors . Warning Symlinks are not followed/supported.","title":"Files (files and files-bin)"},{"location":"configuration/#directories-directories-and-directories-bin","text":"The directories ( string[] | null default [] ) setting is a list of directory paths relative to base-path . All files will be processed by the compactors , have their placeholder values replaced (see: replacements ) and added to the PHAR. Files listed in the blacklist will not be added to the PHAR. directories-bin is analogue to directories except the files are added to the PHAR unmodified. This is suitable for the files such as images, those that contain binary data or simply a file you do not want to alter at all despite using compactors. Warning Setting the key directories (regardless of its value), will disable the file auto-discovery. If you want to keep it, check the force the auto-discovery setting. Warning By default Box excludes some files (e.g. dot files, readmes & co). This is done in order to attempt to reduce the final PHAR size. There is at the moment no way to disable this (maybe this could be done via a new setting) but it remains possible to include them via files , files-bin , directories-bin or your own finder or finder-bin . Warning Symlinks are not followed/supported.","title":"Directories (directories and directories-bin)"},{"location":"configuration/#finder-finder-and-finder-bin","text":"The finder ( object[] | null default [] ) setting is a list of JSON objects. Each object (key, value) tuple is a (method, arguments) of the Symfony Finder used by Box. If an array of values is provided for a single key, the method will be called once per value in the array. Note that the paths specified for the in method are relative to base-path and that the finder will account for the files registered in the blacklist . finder-bin is analogue to finder except the files are added to the PHAR unmodified. This is suitable for the files such as images, those that contain binary data or simply a file you do not want to alter at all despite using compactors . Warning Setting the key finder (regardless of its value), will disable the file auto-discovery. If you want to keep it, check the force the auto-discovery setting. Warning Symlinks are not followed/supported. Example: { \"finder\" : [ { \"notName\" : \"/LICENSE|.*\\\\.md|.*\\\\.dist|Makefile|composer\\\\.json|composer\\\\.lock/\" , \"exclude\" : [ \"doc\" , \"test\" , \"test_old\" , \"tests\" , \"Tests\" , \"vendor-bin\" ], \"in\" : \"vendor\" }, { \"name\" : \"composer.json\" , \"in\" : \".\" } ] }","title":"Finder (finder and finder-bin)"},{"location":"configuration/#blacklist-blacklist","text":"The blacklist ( string[] | null default [] ) setting is a list of files that must not be added. The files blacklisted are the ones found using the other available configuration settings: files , files-bin , directories , directories-bin , finder , finder-bin . Note that all the blacklisted paths are relative to the settings configured above. For example if you have the following file structure: project/ \u251c\u2500\u2500 box.json.dist \u251c\u2500\u2500 A/ | \u251c\u2500\u2500 A00 | \u2514\u2500\u2500 A01 \u2514\u2500\u2500 B/ \u251c\u2500\u2500 B00 \u251c\u2500\u2500 B01 \u2514\u2500\u2500 A/ \u2514\u2500\u2500 BA00 With: { # o t her n o n f ile rela te d se tt i n gs \"blacklist\" : [ \"A\" ] } Box will try to collect all the files found in project (cf. Including files ) but will exclude A/ and `B/A resulting in the following files being collected: project/ \u251c\u2500\u2500 box.json.dist \u2514\u2500\u2500 B/ \u251c\u2500\u2500 B00 \u2514\u2500\u2500 B01 If you want a more granular blacklist leverage, use the Finders configuration instead.","title":"Blacklist (blacklist)"},{"location":"configuration/#excluding-the-composer-files-exclude-composer-files","text":"The exclude-composer-files ( boolean | null , default true ) setting will result in removing the Composer files composer.json , composer.lock and vendor/composer/installed.json if they are found regardless of whether or not they were found by Box alone or explicitly included.","title":"Excluding the Composer files (exclude-composer-files)"},{"location":"configuration/#excluding-dev-files-exclude-dev-files","text":"The exclude-dev-files ( bool default true ) setting will, when enabled, cause Box to attempt to exclude the files belonging to dev only packages. For example for the given project: composer.json { \"require\" : { \"beberlei/assert\" : \"^3.0\" }, \"require-dev\" : { \"bamarni/composer-bin-plugin\" : \"^1.2\" } } The vendor directory will have beberlei/assert and bamarni/composer-bin-plugin . If exclude-dev-files is not disabled, the bamarni/composer-bin-plugin package will be removed from the PHAR. This setting will automatically be disabled when dump-autoload is disabled. Indeed, otherwise some files will not be shipped in the PHAR but may still appear in the Composer autoload classmap, resulting in an autoloading error.","title":"Excluding dev files (exclude-dev-files)"},{"location":"configuration/#map-map","text":"The map ( object[] default [] ) setting is used to change where some (or all) files are stored inside the PHAR. The key is a beginning of the relative path that will be matched against the file being added to the PHAR. If the key is a match, the matched segment will be replaced with the value. If the key is empty, the value will be prefixed to all paths (except for those already matched by an earlier key). For example, with the following configuration excerpt: { \"map\" : [ { \"my/test/path\" : \"src/Test\" }, { \"\" : \"src/Another\" } ] } with the following files added to the PHAR: my/test/path/file.php my/test/path/some/other.php my/test/another.php the above files will be stored with the following paths in the PHAR: src/Test/file.php src/Test/some/other.php src/Another/my/test/another.php","title":"Map (map)"},{"location":"configuration/#stub","text":"The PHAR stub file is the PHAR bootstrapping file, i.e. the very first file executed whenever the PHAR is executed. It usually contains things like the PHAR configuration and executing the main script file . The default PHAR stub file can be used but Box also propose a couple of options to customize the stub used.","title":"Stub"},{"location":"configuration/#stub-stub","text":"The stub ( string | boolean | null default true ) setting is used to specify the location of a stub file or if one should be generated: - string : Path to the stub file will be used as is inside the PHAR - true (default): A new stub will be generated - false : The default stub used by the PHAR class will be used If a custom stub file is provided, none of the other options ( shebang , [ intercept ][intercept] and alias ) are used.","title":"Stub (stub)"},{"location":"configuration/#shebang-shebang","text":"The shebang ( string | false | null ) setting is used to specify the shebang line used when generating a new stub. By default, this line is used: #!/usr/bin/env php The shebang line can be removed altogether if set to false .","title":"Shebang (shebang)"},{"location":"configuration/#intercept-intercept","text":"The intercept ( boolean | null default false ) setting is used when generating a new stub. If setting is set to true , the Phar::interceptFileFuncs() method will be called in the stub.","title":"Intercept (intercept)"},{"location":"configuration/#alias-alias","text":"The alias ( string | null ) setting is used when generating a new stub to call the Phar::mapPhar() . This makes it easier to refer to files in the PHAR and ensure the access to internal files will always work regardless of the location of the PHAR on the file system. If no alias is provided, a generated unique name will be used for it in order to map the main file . Note that this may have undesirable effects if you are using the generated stub Example: // .phar.stub #!/usr/bin/env php <?php if ( class_exists ( 'Phar' )) { Phar :: mapPhar ( 'alias.phar' ); require 'phar://' . __FILE__ . '/index.php' ; } __HALT_COMPILER (); ?> // index.php <?php if ( ! isset ( $GLOBALS [ 'EXECUTE' ])) { $GLOBALS [ 'EXECUTE' ] = true ; } // On the first execution, we require that other file while // on the second we will echo \"Hello world!\" if ( $GLOBALS [ 'EXECUTE' ]) { require 'foo.php' ; } else { echo 'Hello world!' ; } // foo.php <? php $GLOBALS [ 'EXECUTE' ] = false ; // Notice how we are using `phar://alias.phar` here. This will // always work. This allows you to not have to find where the file // is located in the PHAR neither finding the PHAR file path require 'phar://alias.phar/index.php' ; If you are using the default stub, Phar::setAlias() will be used. Note however that this will behave slightly differently. Example: <?php $phar = new Phar ( 'index.phar' ); // Warning: creating a Phar instance results in *loading* the file. From this point, the // PHAR stub file has been loaded and as a result, if the PHAR had an alias the alias // will be registered. $phar -> setAlias ( 'foo.phar' ); $phar -> addFile ( 'LICENSE' ); file_get_contents ( 'phar://foo.phar/LICENSE' ); // Will work both inside the PHAR but as well as outside as soon as the // PHAR is loaded in-memory. As you can see above, loading a PHAR which has an alias result in a non-negligible side effect. A typical case where this might be an issue can be illustrated with box itself. For its end-to-end test, the process is along the lines of: Build a PHAR box.phar from the source code Build the PHAR box.phar from the source again but using the previous PHAR this time If an alias box-alias.phar was registered for both for example, the building would fail. Indeed when building the second PHAR, the first PHAR is loaded which loads the alias box-alias.phar . When creating the second PHAR, box would try to register the alias box-alias.phar to that new PHAR but as the alias is already used, an error will be thrown.","title":"Alias (alias)"},{"location":"configuration/#banner-banner","text":"The banner ( string | string[] | false | null ) setting is the banner comment that will be used when a new stub is generated. The value of this setting must not already be enclosed within a comment block as it will be automatically done for you. For example Custom banner will result in the stub file: /* * Custom banner */ An array of strings can be used for multilines banner: { \"banner\" : [ \"This file is part of the box project.\" , \"\" , \"(c) Kevin Herrera <kevin@herrera.io>\" , \"Th\u00e9o Fidry <theo.fidry@gmail.com>\" , \"\" , \"This source file is subject to the MIT license that is bundled\" , \"with this source code in the file LICENSE.\" ] } Will result in: /* * This file is part of the box project. * * (c) Kevin Herrera <kevin@herrera.io> * Th\u00e9o Fidry <theo.fidry@gmail.com> * * This source file is subject to the MIT license that is bundled * with this source code in the file LICENSE. */ By default, the Box banner is used. If set to false , no banner at all will be used. The content of this value is discarded if banner-file is set.","title":"Banner (banner)"},{"location":"configuration/#banner-file-banner-file","text":"The banner-file ( string | null ignored by default) setting is like banner, except it is a path (relative to the base path ) to the file that will contain the comment. Like banner, the comment must not already be enclosed in a comment block. If this parameter is set to a different value than null , then the value of banner will be discarded.","title":"Banner file (banner-file)"},{"location":"configuration/#dumping-the-composer-autoloader-dump-autoload","text":"The dump-autoload ( boolean | null , default true ) setting will result in Box dump the Composer autoload with the classmap authoritative mode and the --no-dev option which disables the autoload-dev rules. This is however done only if a composer.json file could be found. If a composer.lock file is found as well, the file vendor/composer/installed.json will be required too. The dumping of the autoloader will be ignored if the composer.json file could not be found. The autoloader is dumped at the end of the process to ensure it will take into account the eventual modifications done by the compactors process.","title":"Dumping the Composer autoloader (dump-autoload)"},{"location":"configuration/#compactors-compactors","text":"The compactors ( string[] | null default [] ) setting is a list of file contents compacting classes that must be registered. A file compacting class is used to reduce the size of a specific file type. The following is a simple example: <?php namespace Acme ; use KevinGH\\Box\\Compactor\\Compactor ; class MyCompactor implements Compactor { /** * {@inheritdoc} */ public function compact ( string $file , string $contents ) : string { if ( preg_match ( '/\\.txt/' , \\ $file )) { return trim ( $contents ); } return $contents ; } } The following compactors are included with Box: KevinGH\\Box\\Compactor\\Json : compress JSON files KevinGH\\Box\\Compactor\\Php : strip down classes from phpdocs & comments KevinGH\\Box\\Compactor\\PhpScoper : isolate the code using PHP-Scoper The effects of the compactors and replacement values can be tested with the process command \u2728.","title":"Compactors (compactors)"},{"location":"configuration/#annotations-annotations","text":"The annotations ( boolean | object | null default true ) setting is used to enable compacting annotations in PHP source code. This setting is only taken into consideration if the KevinGH\\Box\\Compactor\\Php compactor is enabled. By default, it removes all non real-like annotations from the PHP code. See the following example: Original code <?php /** * Function comparing the two given values * * @param int $x * @param int $y * * @return int * * @author Th\u00e9o Fidry * @LICENSE MIT * * @Acme(type = \"function\") */ function foo ( $x , $y ) : int { // Compare the two values return $x <=> $y ; } Compacted code <?php /** @Acme(type=\"function\") */ function foo ( $x , $y ) : int { return $x <=> $y ; } Note that the empty line returns are on purpose: it is to keep the same line number for the files between your source code and the code bundled in the PHAR. If you wish to keep all annotations, you can disable the annotations like so: { \"annotations\" : false } For a more granular list, you can manually configure the list of annotations you wish to ignore: { \"annotations\" : { \"ignore\" : [ \"author\" , \"package\" , \"version\" , \"see\" ] } }","title":"Annotations (annotations)"},{"location":"configuration/#php-scoper-php-scoper","text":"The PHP-Scoper setting ( string | null default scoper.inc.php ) points to the path to the PHP-Scoper configuration file. For more documentation regarding PHP-Scoper, you can head to PHAR code isolation or PHP-Scoper official documentation . Note that this setting is used only if the compactor KevinGH\\Box\\Compactor\\PhpScoper is registered.","title":"PHP-Scoper (php-scoper)"},{"location":"configuration/#compression-algorithm-compression","text":"The compression ( string | null default NONE ) setting is the compression algorithm to use when the PHAR is built. The compression affects the individual files within the PHAR and not the PHAR as a whole ( Phar::compressFiles() ). The following is a list of the signature algorithms available: GZ (the most efficient most of the time) BZ2 NONE (default) Warning Be aware that if compressed, the PHAR will required the appropriate extension ( zlib for GZ and bz2 for BZ2 ) to execute the PHAR. Without it, PHP will not be able to open the PHAR at all.","title":"Compression algorithm (compression)"},{"location":"configuration/#security","text":"","title":"Security"},{"location":"configuration/#signing-algorithm-algorithm","text":"The algorithm ( string | null default SHA1 ) setting is the signing algorithm to use when the PHAR is built ( Phar::setSignatureAlgorithm() ). The following is a list of the signature algorithms available: MD5 SHA1 SHA256 SHA512 OPENSSL By default PHARs are SHA1 signed. The OPENSSL algorithm will require to provide a key .","title":"Signing algorithm (algorithm)"},{"location":"configuration/#the-private-key-key","text":"The key ( string | null default null ) setting is used to specify the path to the private key file. The private key file will be used to sign the PHAR using the OPENSSL signature algorithm (see Signing algorithm ) and the setting will be completely ignored otherwise. If an absolute path is not provided, the path will be relative to the current working directory.","title":"The private key (key)"},{"location":"configuration/#the-private-key-password-key-pass","text":"The private key password ( string | boolean | null default null ) setting is used to specify the pass-phrase for the private key. If a string is provided, it will be used as is as the pass-phrase. If true is provided, you will be prompted for the passphrase unless you are not in an interactive environment. This setting will be ignored if no key has been provided.","title":"The private key password (key-pass)"},{"location":"configuration/#metadata-metadata","text":"The metadata ( any default none) setting can be any value. This value will be stored as metadata that can be retrieved from the built PHAR ( Phar::getMetadata() ). If you specify a callable (as a string), it will be evaluated without any arguments. For example, if you take the following code: <?php # callable_script.php class MyCallbacks { public static function generateMetadata () { return [ 'application_version' => '1.0.0-dev' ]; } } With the configuration excerpt: { \"metadata\" : \"MyCallbacks::generateMetadata\" } Then the Phar::getMetadata() will return ['application_version' => '1.0.0-dev'] array. CAUTION : Your callable function must be readable by your autoloader. That means, for Composer, in previous example, we require to have such kind of declaration in your composer.json file. { \"autoload\" : { \"files\" : [ \"/path/to/your/callable_script.php\" ] } }","title":"Metadata (metadata)"},{"location":"configuration/#replaceable-placeholders","text":"This feature allows you to set placeholders in your code which will be replaced by different values by Box when building the PHAR. For example, if you take the following code: <?php class Application { public function getVersion () : string { return '@git_commit_short@' ; } } With the configuration excerpt: { \"git-commit-short\" : \"git_commit_short\" } Then the actual code shipped in the PHAR will be: <?php class Application { public function getVersion () : string { return 'a6c5d93' ; } } The @ is the default value of the sigil which is the placeholders delimited and git-commit-short is one of the built in placeholder. Box ships a few buit-in placeholders which you can find bellow, but you can also specify any replacement value via the replacements setting . The effects of the compactors and replacement values can be tested with the process command \u2728.","title":"Replaceable placeholders"},{"location":"configuration/#replacements-replacements","text":"The replacements ( object | null , default {} ) setting is a map of placeholders (as keys) and their values. The placeholders are replaced in all non-binary files with the specified values. For example: { \"replacements\" : { \"foo\" : \"bar\" } } Will result in the string @foo@ in your code to be replaced by 'bar' . The delimiter @ being the sigil .","title":"Replacements (replacements)"},{"location":"configuration/#replacement-sigil-replacement-sigil","text":"The replacement sigil ( string | null default @ ) is the character or chain of characters used to delimit the placeholders. See the @ replacements setting for examples of placeholders.","title":"Replacement sigil (replacement-sigil)"},{"location":"configuration/#datetime-placeholder-datetime","text":"The datetime ( string | null default null ) setting is the name of a placeholder value that will be replaced in all non-binary files by the current datetime. If no value is given ( null ) then this placeholder will be ignored. Example value the placeholder will be replaced with: 2015-01-28 14:55:23 CEST The format of the date used is defined by the datetime-format setting .","title":"Datetime placeholder (datetime)"},{"location":"configuration/#datetime-placeholder-format-datetime-format","text":"The datetime format placeholder ( string | null , default Y-m-d H:i:s T ) setting accepts a valid PHP date format . It can be used to change the format for the datetime setting.","title":"Datetime placeholder format (datetime-format)"},{"location":"configuration/#pretty-git-tag-placeholder-git","text":"The git tag placeholder ( string | null default null ) setting is the name of a placeholder value that will be replaced in all non-binary files by the current git tag of the repository. Example of value the placeholder will be replaced with: 2.0.0 on an exact tag match 2.0.0@e558e33 on a commit following a tag","title":"Pretty git tag placeholder (git)"},{"location":"configuration/#git-commit-placeholder-git-commit","text":"The git commit ( string | null default null ) setting is the name of a placeholder value that will be replaced in all non-binary files by the current git commit hash of the repository. Example of value the placeholder will be replaced with: e558e335f1d165bc24d43fdf903cdadd3c3cbd03","title":"Git commit placeholder (git-commit)"},{"location":"configuration/#short-git-commit-placeholder-git-commit-short","text":"The short git commit ( string | null default null ) setting is the name of a placeholder value that will be replaced in all non-binary files by the current git short commit hash of the repository. Example of value the placeholder will be replaced with: e558e33","title":"Short git commit placeholder (git-commit-short)"},{"location":"configuration/#git-tag-placeholder-git-tag","text":"The git tag placeholder ( string | null default null ) setting is the name of a placeholder value that will be replaced in all non-binary files by the current git tag of the repository. Example of value the placeholder will be replaced with: 2.0.0 on an exact tag match 2.0.0-2-ge558e33 on a commit following a tag","title":"Git tag placeholder (git-tag)"},{"location":"configuration/#git-version-placeholder-git-version","text":"The git version ( string | null default null ) setting is the name of a placeholder value that will be replaced in all non-binary files by the one of the following (in order): The git repository's most recent tag. The git repository's current short commit hash. The short commit hash will only be used if no tag is available. \u00ab Installation \u2022 Requirement Checker \u00bb","title":"Git version placeholder (git-version)"},{"location":"docker/","text":"Docker support Besides generating a PHAR, you may want to create a Docker image for your application. To do so, you can either: Directly generate the Dockerfile when generating the PHAR with the --with-docker option of the Box compile command Generate the Dockerfile for a given PHAR with the Box docker command The command will attempt to generate a Dockerfile for your PHAR, leveraging the requirement checker . Once the file generated, you have free hands on it: you can either use it right away (you just need to run $ docker build . to create the docker image) or you can tweak it however you want. In your Dockerfile (generated by Box), you should see the following line: RUN $( php -r '$extensionInstalled = array_map(\"strtolower\", \\get_loaded_extensions(false));$requiredExtensions = [\"zlib\", \"phar\", \"openssl\", \"pcre\", \"tokenizer\"];$extensionsToInstall = array_diff($requiredExtensions, $extensionInstalled);if ([] !== $extensionsToInstall) {echo \\sprintf(\"docker-php-ext-install %s\", implode(\" \", $extensionsToInstall));}echo \"echo \\\"No extensions\\\"\";' ) This cryptic one-liner PHP script is about installing the required extensions for your application: it compares the ones your application requires with the ones already provided by the base PHP image, and then install them using the docker-php-ext-install command. It is however possible that this fails for various reason: the extension is not a known one, it cannot be installed the traditional way, it needs to be compiled with PHP... For all those cases (unless you have a better way to handle it in which case PRs are welcomed) you will have to dirty your hands and tweak the Dockerfile to your needs. \u00ab PHAR code isolation \u2022 Symfony supports \u00bb","title":"Docker support"},{"location":"docker/#docker-support","text":"Besides generating a PHAR, you may want to create a Docker image for your application. To do so, you can either: Directly generate the Dockerfile when generating the PHAR with the --with-docker option of the Box compile command Generate the Dockerfile for a given PHAR with the Box docker command The command will attempt to generate a Dockerfile for your PHAR, leveraging the requirement checker . Once the file generated, you have free hands on it: you can either use it right away (you just need to run $ docker build . to create the docker image) or you can tweak it however you want. In your Dockerfile (generated by Box), you should see the following line: RUN $( php -r '$extensionInstalled = array_map(\"strtolower\", \\get_loaded_extensions(false));$requiredExtensions = [\"zlib\", \"phar\", \"openssl\", \"pcre\", \"tokenizer\"];$extensionsToInstall = array_diff($requiredExtensions, $extensionInstalled);if ([] !== $extensionsToInstall) {echo \\sprintf(\"docker-php-ext-install %s\", implode(\" \", $extensionsToInstall));}echo \"echo \\\"No extensions\\\"\";' ) This cryptic one-liner PHP script is about installing the required extensions for your application: it compares the ones your application requires with the ones already provided by the base PHP image, and then install them using the docker-php-ext-install command. It is however possible that this fails for various reason: the extension is not a known one, it cannot be installed the traditional way, it needs to be compiled with PHP... For all those cases (unless you have a better way to handle it in which case PRs are welcomed) you will have to dirty your hands and tweak the Dockerfile to your needs. \u00ab PHAR code isolation \u2022 Symfony supports \u00bb","title":"Docker support"},{"location":"faq/","text":"FAQ What is the canonical way to write a CLI entry file? The shebang The PHP_SAPI check Autoloading Composer Detecting that you are inside a PHAR What is the canonical way to write a CLI entry file? A conventional CLI entry file looks like this (see bellow for further explanations): #!/usr/bin/env php <?php declare ( strict_types = 1 ); namespace Acme ; use function in_array ; use const PHP_EOL ; use const PHP_SAPI ; use RuntimeException ; if ( false === in_array ( PHP_SAPI , [ 'cli' , 'phpdbg' , 'embed' ], true )) { echo PHP_EOL . 'This app may only be invoked from a command line, got \"' . PHP_SAPI . '\"' . PHP_EOL ; exit ( 1 ); } ( static function () : void { if ( file_exists ( $autoload = __DIR__ . '/../../../autoload.php' )) { // Is installed via Composer include_once $autoload ; return ; } if ( file_exists ( $autoload = __DIR__ . '/../vendor/autoload.php' )) { // Is installed locally include_once $autoload ; return ; } throw new RuntimeException ( 'Unable to find the Composer autoloader.' ); })(); // Execute the application The shebang The shebang #!/usr/bin/env php is required to the auto-detection of the type of the script. This allows to use it as follows: $ chmod +x bin/acme.php $ ./bin/acme.php $ php bin/acme.php # still works # Without the shebang line, you can only use the latter In other words it is not necessary, but a nice to have if you want to make your file executable. The PHP_SAPI check For PHP, available SAPIs are: Apache2 (mod_php), FPM, CGI, FastCGI and CLI. There is a few other variants but those are the most commons ones. For more information, see the official PHP doc . So the following: if (false === in_array(PHP_SAPI, ['cli', 'phpdbg', 'embed'], true)) { echo PHP_EOL.'This app may only be invoked from a command line, got \"'.PHP_SAPI.'\"'.PHP_EOL; exit(1); } is purely ot make sure your CLI application is not executed in a non CLI context (for example via a web server). Doing so prevents you to have to worry about web-server related vulnerabilities such as HTTPoxy . cli is the standard default you will get phpdbg when executing PHP with PHPDBG embed if you compile the PHP/ZE into another program Autoloading Composer When developing a CLI application, you generally only need to worry about your local autoloader: include_once __DIR__.'/../vendor/autoload.php'; However, if the application is also published as a Composer package, then the autoloader may be found in a different location: include_once __DIR__.'/../../../autoload.php'; In either cases however, it could be the autoloader file is missing (e.g. if the dependencies are not installed yet). So it is wise to wrap them in a file_exist() check and provide a user-friendly error when no autoloader could be found. Detecting that you are inside a PHAR The easiest way to know if your script is executed from within a PHAR is to run the following: $isInPhar = '' !== Phar::running(false); See Phar::running() for more information. \u00ab Symfony supports \u2022 Table of Contents \u00bb","title":"FAQ"},{"location":"faq/#faq","text":"What is the canonical way to write a CLI entry file? The shebang The PHP_SAPI check Autoloading Composer Detecting that you are inside a PHAR","title":"FAQ"},{"location":"faq/#what-is-the-canonical-way-to-write-a-cli-entry-file","text":"A conventional CLI entry file looks like this (see bellow for further explanations): #!/usr/bin/env php <?php declare ( strict_types = 1 ); namespace Acme ; use function in_array ; use const PHP_EOL ; use const PHP_SAPI ; use RuntimeException ; if ( false === in_array ( PHP_SAPI , [ 'cli' , 'phpdbg' , 'embed' ], true )) { echo PHP_EOL . 'This app may only be invoked from a command line, got \"' . PHP_SAPI . '\"' . PHP_EOL ; exit ( 1 ); } ( static function () : void { if ( file_exists ( $autoload = __DIR__ . '/../../../autoload.php' )) { // Is installed via Composer include_once $autoload ; return ; } if ( file_exists ( $autoload = __DIR__ . '/../vendor/autoload.php' )) { // Is installed locally include_once $autoload ; return ; } throw new RuntimeException ( 'Unable to find the Composer autoloader.' ); })(); // Execute the application","title":"What is the canonical way to write a CLI entry file?"},{"location":"faq/#the-shebang","text":"The shebang #!/usr/bin/env php is required to the auto-detection of the type of the script. This allows to use it as follows: $ chmod +x bin/acme.php $ ./bin/acme.php $ php bin/acme.php # still works # Without the shebang line, you can only use the latter In other words it is not necessary, but a nice to have if you want to make your file executable.","title":"The shebang"},{"location":"faq/#the-php_sapi-check","text":"For PHP, available SAPIs are: Apache2 (mod_php), FPM, CGI, FastCGI and CLI. There is a few other variants but those are the most commons ones. For more information, see the official PHP doc . So the following: if (false === in_array(PHP_SAPI, ['cli', 'phpdbg', 'embed'], true)) { echo PHP_EOL.'This app may only be invoked from a command line, got \"'.PHP_SAPI.'\"'.PHP_EOL; exit(1); } is purely ot make sure your CLI application is not executed in a non CLI context (for example via a web server). Doing so prevents you to have to worry about web-server related vulnerabilities such as HTTPoxy . cli is the standard default you will get phpdbg when executing PHP with PHPDBG embed if you compile the PHP/ZE into another program","title":"The PHP_SAPI check"},{"location":"faq/#autoloading-composer","text":"When developing a CLI application, you generally only need to worry about your local autoloader: include_once __DIR__.'/../vendor/autoload.php'; However, if the application is also published as a Composer package, then the autoloader may be found in a different location: include_once __DIR__.'/../../../autoload.php'; In either cases however, it could be the autoloader file is missing (e.g. if the dependencies are not installed yet). So it is wise to wrap them in a file_exist() check and provide a user-friendly error when no autoloader could be found.","title":"Autoloading Composer"},{"location":"faq/#detecting-that-you-are-inside-a-phar","text":"The easiest way to know if your script is executed from within a PHAR is to run the following: $isInPhar = '' !== Phar::running(false); See Phar::running() for more information. \u00ab Symfony supports \u2022 Table of Contents \u00bb","title":"Detecting that you are inside a PHAR"},{"location":"installation/","text":"Installation PHAR Phive Composer Homebrew PHAR The preferred method of installation is to use the Box PHAR which can be downloaded from the most recent Github Release . This method ensures you will not have any dependency conflict issue. Phive You can install Box with Phive $ phive install humbug/box To upgrade box use the following command: $ phive update humbug/box Composer You can install Box with Composer : $ composer global require humbug/box If you cannot install it because of a dependency conflict or you prefer to install it for your project, we recommend you to take a look at bamarni/composer-bin-plugin . Example: $ composer require --dev bamarni/composer-bin-plugin $ composer bin box require --dev humbug/box $ vendor/bin/box Homebrew To install box using Homebrew , you need to tap the box formula first $ brew tap humbug/box $ brew install box The box command is now available to run from anywhere in the system: $ box -v To upgrade box use the following command: $ brew upgrade box \u00ab Table of Contents \u2022 Usage \u00bb","title":"Installation"},{"location":"installation/#installation","text":"PHAR Phive Composer Homebrew","title":"Installation"},{"location":"installation/#phar","text":"The preferred method of installation is to use the Box PHAR which can be downloaded from the most recent Github Release . This method ensures you will not have any dependency conflict issue.","title":"PHAR"},{"location":"installation/#phive","text":"You can install Box with Phive $ phive install humbug/box To upgrade box use the following command: $ phive update humbug/box","title":"Phive"},{"location":"installation/#composer","text":"You can install Box with Composer : $ composer global require humbug/box If you cannot install it because of a dependency conflict or you prefer to install it for your project, we recommend you to take a look at bamarni/composer-bin-plugin . Example: $ composer require --dev bamarni/composer-bin-plugin $ composer bin box require --dev humbug/box $ vendor/bin/box","title":"Composer"},{"location":"installation/#homebrew","text":"To install box using Homebrew , you need to tap the box formula first $ brew tap humbug/box $ brew install box The box command is now available to run from anywhere in the system: $ box -v To upgrade box use the following command: $ brew upgrade box \u00ab Table of Contents \u2022 Usage \u00bb","title":"Homebrew"},{"location":"optimizations/","text":"Optimize your PHAR Review your files Compress your PHAR Optimize your code Review your files By default Box try to be smart about which files are required and will attempt to use only the necessary files. You can list the files of your PHAR with the box info --list command. It is however possible you want a finer control in which case you can adapt the included files thanks to the configuration options . All the files in the PHAR are loaded in-memory when executing a PHAR. As a result, the more content there is to load, the bigger the overhead will be and unlike your regular application, a PHAR will not benefit from the opcache optimisations. The difference should however be minimal unless you have dozens of thousands of files in which case you might either accept it, consider an alternative or contribute to the PHAR extension in order to optimise it. Compress your PHAR You can also greatly enhance the size of your PHAR by compressing it: The compression algorithm setting . It is very efficient, however note that a compressed PHAR requires the zip PHP extension and has a (micro) overhead since PHP needs to uncompress the archive before using it Compactors can also help to compress some contents for example by removing the unnecessary comments and spaces in PHP and JSON files. Optimize your code Another code performance optimisation that can be done is always use fully qualified symbols or use statements. For example the following: <?php namespace Acme ; use stdClass ; use const BAR ; use function foo ; new stdClass (); foo ( BAR ); Will be more performant than: <?php namespace Acme ; use stdClass ; new stdClass (); foo ( BAR ); Indeed in the second case, PHP is unable to know from where foo or BAR comes from. So it will first try to find \\Acme\\foo and \\Acme\\BAR and if not found will fallback to \\foo and BAR . This fallback lookup creates a minor overhead. Besides some functions such as count are optimised by opcache so using a fully qualified call \\count or importing it via a use statement use function count will be even more optimised. However you may not want to care and change your code for such micro optimisations. But if you do, know that isolating your PHAR code will transform every call into a fully qualified call whenever possible enabling that optimisation for your PHAR. \u00ab Requirement Checker \u2022 PHAR code isolation \u00bb","title":"Optimize your PHAR"},{"location":"optimizations/#optimize-your-phar","text":"Review your files Compress your PHAR Optimize your code","title":"Optimize your PHAR"},{"location":"optimizations/#review-your-files","text":"By default Box try to be smart about which files are required and will attempt to use only the necessary files. You can list the files of your PHAR with the box info --list command. It is however possible you want a finer control in which case you can adapt the included files thanks to the configuration options . All the files in the PHAR are loaded in-memory when executing a PHAR. As a result, the more content there is to load, the bigger the overhead will be and unlike your regular application, a PHAR will not benefit from the opcache optimisations. The difference should however be minimal unless you have dozens of thousands of files in which case you might either accept it, consider an alternative or contribute to the PHAR extension in order to optimise it.","title":"Review your files"},{"location":"optimizations/#compress-your-phar","text":"You can also greatly enhance the size of your PHAR by compressing it: The compression algorithm setting . It is very efficient, however note that a compressed PHAR requires the zip PHP extension and has a (micro) overhead since PHP needs to uncompress the archive before using it Compactors can also help to compress some contents for example by removing the unnecessary comments and spaces in PHP and JSON files.","title":"Compress your PHAR"},{"location":"optimizations/#optimize-your-code","text":"Another code performance optimisation that can be done is always use fully qualified symbols or use statements. For example the following: <?php namespace Acme ; use stdClass ; use const BAR ; use function foo ; new stdClass (); foo ( BAR ); Will be more performant than: <?php namespace Acme ; use stdClass ; new stdClass (); foo ( BAR ); Indeed in the second case, PHP is unable to know from where foo or BAR comes from. So it will first try to find \\Acme\\foo and \\Acme\\BAR and if not found will fallback to \\foo and BAR . This fallback lookup creates a minor overhead. Besides some functions such as count are optimised by opcache so using a fully qualified call \\count or importing it via a use statement use function count will be even more optimised. However you may not want to care and change your code for such micro optimisations. But if you do, know that isolating your PHAR code will transform every call into a fully qualified call whenever possible enabling that optimisation for your PHAR. \u00ab Requirement Checker \u2022 PHAR code isolation \u00bb","title":"Optimize your code"},{"location":"requirement-checker/","text":"Requirements checker Configuration PHP version requirements Extension configuration requirements Polyfills Integration with a custom stub Unlike when installing a library with Composer , no constraint check is done by default with a PHAR. As a result, if you are using a PHAR of an application compatible with PHP 7.2 in PHP 7.0 or a PHP environment which does not have a required extension, it will simply break with a non-friendly error. By default, when building your PHAR, Box will look up for the PHP versions and extensions required to execute your application according to your composer.json and composer.lock files and ship a micro (~280KB uncompressed and >40KB compressed) requirements checker which will be executed when starting your PHAR. The following are screenshots of the output when an error occurs (left) in a non-quiet verbosity and when all requirements are passing on the right in debug verbosity. Warning this check is still done within the PHAR. As a result, if the required extension to open the PHAR due to the compression algorithm is not loaded, a hard failure will still appear: the requirement checker cannot be executed before that. Configuration Box will retrieve all the (non-dev) requirements including the ones of the dependencies if there is any. When a composer.lock file is present, it will take the information from it. If not found, it will fallback on the composer.json but that it will not be able to retrieve any information regarding the dependencies requirements in this case. PHP version requirements To register a minimal PHP version required by your application, you can register it as a requirement: { \"require\" : { \"php\" : \"^7.2\" } } Note that configuring the application to run in a specific version will not affect it. So in the following example: { \"require\" : { \"php\" : \"^7.1\" }, \"config\" : { \"platform\" : { \"php\" : \"7.1.10\" } } } In the above example, Composer will emulate PHP 7.1.10 environment. This makes sure that when installing the dependencies, they will be compatible with 7.1.10+. It will however not affect the application requirements and as a result Box will pick ^7.1 as the PHP requirement. Extension configuration requirements To register an extension, you can specify it like so: { \"require\" : { \"ext-mbstring\" : \"*\" } } Note that although you can specify a specific version for the extension requirements, Box does not currently support it and will simply understand that the given extension is required regardless of the version specified. Polyfills Box supports the following polyfills: symfony/polyfill-<extension-name> for any extension paragonie/sodium_compat for the libsodium extension phpseclib/mcrypt_compat for the mcrypt extension For example, if you have the following configuration: { \"require\" : { \"ext-mbstring\" : \"*\" , \"symfony/polyfill-mbstring\" : \"^1.0\" } } Then the mbstring extension will not be required since its polyfill has been found. Functions requirements/polyfills are not supported at the moment, see #131 . Integration with a custom stub If you are using your own stub instead of the Box autogenerated one, you can still require the requirement checker manually. When building the PHAR, Box will add the requirement checker in the .box directory. As a result, you can require the requirement checker script .box/check_requirements.php like so: // Stub file // Example where the PHAR used has the alias `acme.phar` require 'phar://acme.phar/.box/check_requirements.php'; The requirement checker works down to PHP 7.2.5+. If however you are including it after your custom code which is not PHP 7.2.5+ compatible, it will fail before the requirements are being checked. Skipping the requirement checker When the requirement checker is shipped, you can always skip it by setting the environment variable BOX_REQUIREMENT_CHECKER to 0 . For example if you are using the box.phar which ships a requirement checker and want to skip it, you can run: $ BOX_REQUIREMENT_CHECKER=0 php box.phar \u00ab Configuration \u2022 Optimize your PHAR \u00bb","title":"Requirements checker"},{"location":"requirement-checker/#requirements-checker","text":"Configuration PHP version requirements Extension configuration requirements Polyfills Integration with a custom stub Unlike when installing a library with Composer , no constraint check is done by default with a PHAR. As a result, if you are using a PHAR of an application compatible with PHP 7.2 in PHP 7.0 or a PHP environment which does not have a required extension, it will simply break with a non-friendly error. By default, when building your PHAR, Box will look up for the PHP versions and extensions required to execute your application according to your composer.json and composer.lock files and ship a micro (~280KB uncompressed and >40KB compressed) requirements checker which will be executed when starting your PHAR. The following are screenshots of the output when an error occurs (left) in a non-quiet verbosity and when all requirements are passing on the right in debug verbosity. Warning this check is still done within the PHAR. As a result, if the required extension to open the PHAR due to the compression algorithm is not loaded, a hard failure will still appear: the requirement checker cannot be executed before that.","title":"Requirements checker"},{"location":"requirement-checker/#configuration","text":"Box will retrieve all the (non-dev) requirements including the ones of the dependencies if there is any. When a composer.lock file is present, it will take the information from it. If not found, it will fallback on the composer.json but that it will not be able to retrieve any information regarding the dependencies requirements in this case.","title":"Configuration"},{"location":"requirement-checker/#php-version-requirements","text":"To register a minimal PHP version required by your application, you can register it as a requirement: { \"require\" : { \"php\" : \"^7.2\" } } Note that configuring the application to run in a specific version will not affect it. So in the following example: { \"require\" : { \"php\" : \"^7.1\" }, \"config\" : { \"platform\" : { \"php\" : \"7.1.10\" } } } In the above example, Composer will emulate PHP 7.1.10 environment. This makes sure that when installing the dependencies, they will be compatible with 7.1.10+. It will however not affect the application requirements and as a result Box will pick ^7.1 as the PHP requirement.","title":"PHP version requirements"},{"location":"requirement-checker/#extension-configuration-requirements","text":"To register an extension, you can specify it like so: { \"require\" : { \"ext-mbstring\" : \"*\" } } Note that although you can specify a specific version for the extension requirements, Box does not currently support it and will simply understand that the given extension is required regardless of the version specified.","title":"Extension configuration requirements"},{"location":"requirement-checker/#polyfills","text":"Box supports the following polyfills: symfony/polyfill-<extension-name> for any extension paragonie/sodium_compat for the libsodium extension phpseclib/mcrypt_compat for the mcrypt extension For example, if you have the following configuration: { \"require\" : { \"ext-mbstring\" : \"*\" , \"symfony/polyfill-mbstring\" : \"^1.0\" } } Then the mbstring extension will not be required since its polyfill has been found. Functions requirements/polyfills are not supported at the moment, see #131 .","title":"Polyfills"},{"location":"requirement-checker/#integration-with-a-custom-stub","text":"If you are using your own stub instead of the Box autogenerated one, you can still require the requirement checker manually. When building the PHAR, Box will add the requirement checker in the .box directory. As a result, you can require the requirement checker script .box/check_requirements.php like so: // Stub file // Example where the PHAR used has the alias `acme.phar` require 'phar://acme.phar/.box/check_requirements.php'; The requirement checker works down to PHP 7.2.5+. If however you are including it after your custom code which is not PHP 7.2.5+ compatible, it will fail before the requirements are being checked.","title":"Integration with a custom stub"},{"location":"requirement-checker/#skipping-the-requirement-checker","text":"When the requirement checker is shipped, you can always skip it by setting the environment variable BOX_REQUIREMENT_CHECKER to 0 . For example if you are using the box.phar which ships a requirement checker and want to skip it, you can run: $ BOX_REQUIREMENT_CHECKER=0 php box.phar \u00ab Configuration \u2022 Optimize your PHAR \u00bb","title":"Skipping the requirement checker"},{"location":"symfony/","text":"Symfony support Project directory Cache Project directory Symfony 5.1+ defines the \"project dir\" as the directory where the composer.json file is. Because box deletes it during PHAR compilation, you need to redefine it in your Kernel. It is usually located in src/Kernel.php and can be defined as follow: <?php class Kernel extends BaseKernel { ... public function getProjectDir () { return __DIR__ . '/../' ; } } Cache What makes Symfony a bit special for shipping it into a PHAR is its compilation step. Indeed the Symfony container can be dumped depending on multiple parameters such the application environment, whether it is in debug mode or not and if the cache is fresh. A PHAR however is a readonly only environment, which means the container cannot be dumped once inside the PHAR. To prevent the issue, you need to make sure of the following: The cache is warmed up before being shipped within the PHAR The application within the PHAR is running in production mode To achieve this with the least amount of changes is to: Create the .env.local.php file by running the following command: $ composer dump-env prod This will ensure when loading the variables that your application is in production mode. Change the following part of the composer.json file: \"scripts\" : { \"auto-scripts\" : { \"cache:clear\" : \"symfony-cmd\" , \"assets:install %PUBLIC_DIR%\" : \"symfony-cmd\" }, \"post-install-cmd\" : [ \"@auto-scripts\" ], \"post-update-cmd\" : [ \"@auto-scripts\" ] }, For: \"scripts\" : { \"auto-scripts\" : { \"cache:clear\" : \"symfony-cmd\" }, \"post-autoload-dump\" : [ \"@auto-scripts\" ] }, I.e.: You skip the installation of assets (which you shouldn't need in the context of a CLI application) Trigger the auto-scripts, which includes the cache warming phase, on the Composer dump-autoload event This last part takes advantage of Box dumping the autoloader by default. \u00ab Docker support \u2022 FAQ \u00bb","title":"Symfony support"},{"location":"symfony/#symfony-support","text":"Project directory Cache","title":"Symfony support"},{"location":"symfony/#project-directory","text":"Symfony 5.1+ defines the \"project dir\" as the directory where the composer.json file is. Because box deletes it during PHAR compilation, you need to redefine it in your Kernel. It is usually located in src/Kernel.php and can be defined as follow: <?php class Kernel extends BaseKernel { ... public function getProjectDir () { return __DIR__ . '/../' ; } }","title":"Project directory"},{"location":"symfony/#cache","text":"What makes Symfony a bit special for shipping it into a PHAR is its compilation step. Indeed the Symfony container can be dumped depending on multiple parameters such the application environment, whether it is in debug mode or not and if the cache is fresh. A PHAR however is a readonly only environment, which means the container cannot be dumped once inside the PHAR. To prevent the issue, you need to make sure of the following: The cache is warmed up before being shipped within the PHAR The application within the PHAR is running in production mode To achieve this with the least amount of changes is to: Create the .env.local.php file by running the following command: $ composer dump-env prod This will ensure when loading the variables that your application is in production mode. Change the following part of the composer.json file: \"scripts\" : { \"auto-scripts\" : { \"cache:clear\" : \"symfony-cmd\" , \"assets:install %PUBLIC_DIR%\" : \"symfony-cmd\" }, \"post-install-cmd\" : [ \"@auto-scripts\" ], \"post-update-cmd\" : [ \"@auto-scripts\" ] }, For: \"scripts\" : { \"auto-scripts\" : { \"cache:clear\" : \"symfony-cmd\" }, \"post-autoload-dump\" : [ \"@auto-scripts\" ] }, I.e.: You skip the installation of assets (which you shouldn't need in the context of a CLI application) Trigger the auto-scripts, which includes the cache warming phase, on the Composer dump-autoload event This last part takes advantage of Box dumping the autoloader by default. \u00ab Docker support \u2022 FAQ \u00bb","title":"Cache"},{"location":"usage/","text":"Creating a PHAR should be as simple as running box compile ( no config required! ). It will however assume some defaults that you might want to change. Box will by default be looking in order for the files box.json and box.json.dist in the current working directory. A basic configuration could be for example changing the PHAR permissions: { \"chmod\" : \"0700\" } You can then find more advanced configuration settings in the configuration documentation . For more information on which command or options is available, you can run: $ box help \u00ab Installation \u2022 Configuration \u00bb","title":"Usage"}]}
{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#goal","title":"Goal","text":"<p>The Box application simplifies the PHAR building process. Out of the box (no pun intended), the application can do many great things:</p> <ul> <li>\u26a1  Fast application bundling</li> <li>\ud83d\udd28 PHAR isolation</li> <li>\u2699\ufe0f Zero configuration by default</li> <li>\ud83d\ude94 Requirements checker</li> <li>\ud83d\udea8 Friendly error logging experience</li> <li>\ud83d\udd0d Retrieve information about the PHAR extension or a PHAR file and its contents (<code>box info</code> or <code>box diff</code>)</li> <li>\ud83d\udd10\ufe0f Verify the signature of an existing PHAR (<code>box verify</code>)</li> <li>\ud83d\udcdd Use Git tags and short commit hashes for versioning</li> <li>\ud83d\udd75\ufe0f\ufe0f Get recommendations and warnings about regarding your configuration (<code>box validate</code>)</li> <li>\ud83d\udc33 Docker support (<code>box docker</code>)</li> </ul>"},{"location":"#docs","title":"Docs","text":"<p>Go do the documentation.</p>"},{"location":"#usage","title":"Usage","text":"<p>Creating a PHAR should be as simple as running <code>box compile</code> (no config required!). It will however assume some defaults that you might want to change. Box will by default be looking in order for the files <code>box.json</code> and <code>box.json.dist</code> in the current working directory. A basic configuration could be for example changing the PHAR permissions:</p> <pre><code>{\n    \"chmod\": \"0700\"\n}\n</code></pre> <p>You can then find more advanced configuration settings in the configuration documentation. For more information on which command or options is available, you can run:</p> <pre><code>box help\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<p>The project provides a <code>Makefile</code> in which the most common commands have been registered such as fixing the coding style or running the test.</p> <pre><code>make\n</code></pre>"},{"location":"#backward-compatibility-promise-bcp","title":"Backward Compatibility Promise (BCP)","text":"<p>The policy is for the major part following the same as Symfony's one. Note that the code marked as <code>@private</code> or <code>@internal</code> are excluded from the BCP.</p> <p>The text displayed by the commands (e.g. <code>compile</code> or <code>info</code>) or the content of the error/exception messages are also not subject to the BCP.</p>"},{"location":"#credits","title":"Credits","text":"<p>Project originally created by: Kevin Herrera (@kherge) which has now been moved under the Humbug umbrella.</p>"},{"location":"code-isolation/","title":"PHAR code isolation","text":"<ol> <li>Why/Explanation</li> <li>Isolating the PHAR</li> <li>Debugging the scoping</li> </ol>"},{"location":"code-isolation/#whyexplanation","title":"Why/Explanation","text":"<p>When bundling the code in a PHAR, it is equivalent to compacting all the code in a single file. However unlike in a compiled language, the code does not change. This, when the PHAR loads external code, can lead to dependency conflicts.</p> <p>To illustrate that issue with an example: we are building a console application <code>myapp.phar</code> which relies on the library Symfony YAML 2.8.0 which execute a given PHP script.</p> <pre><code># Usage of the application we are building\nmyapp.phar myscript.php\n</code></pre> <p>For the sake of the example, <code>myapp.phar</code> is using Composer and loads the YAML component right away when starting, i.e. when running <code>myapp.phar</code>, the class <code>Symfony\\Yaml\\Yaml</code> from the PHAR is going to be loaded. Now what <code>myapp.phar</code> is actually going to do is scan the whole file given, and do some reflection work on each classes found. I.e. for each class <code>$class</code> found, it will do <code>new \\ReflectionClass($class)</code>.</p> <p>Now if <code>myscript.php</code> is using the Symfony YAML 4.0.0 component with some new features added in 4.0.0 that are non-existent in 2.8.0, when doing <code>new \\ReflectionClass('Symfony\\Yaml\\Yaml')</code>, the class <code>Symfony\\Yaml\\Yaml</code> will be loaded (yes, doing reflection on a class loads it!). BUT, it turns out the class <code>Symfony\\Yaml\\Yaml</code> is already loaded: not the 4.0.0 from <code>myscript.php</code> but the one from the PHAR (<code>2.8.0</code>). So any information you will get will be from the wrong class!</p> <p>Is this really an issue? The answer is it depends. Here as a few real life example where this is an issue:</p> <ul> <li>A static analysis tool like PHPStan</li> <li>A test framework like PHPUnit</li> <li>A quality analysis tool like SymfonyInsight which executes arbitrary code (e.g. to check)   that the application is booting</li> <li>A piece of code that can be mixed with any code, such as a Wordpress plugin</li> </ul>"},{"location":"code-isolation/#isolating-the-phar","title":"Isolating the PHAR","text":"<p>Box provides an integration with PHP-Scoper. To use it, enable the <code>KevinGH\\Box\\Compactor\\PhpScoper</code> compactor.</p> <p>If you need an extra configuration for PHP-Scoper, you can create a <code>scoper.inc.php</code> file as per the documentation. The only difference is that you can ignore the <code>finders</code> setting as the files to scope are already collected by Box.</p> <p>And that's it!</p> <p>Warning: keep in mind however that scoping is a very brittle process due to the nature of PHP. As such you will likely need some adjustments in your code or the configuration.</p>"},{"location":"code-isolation/#debugging-the-scoping","title":"Debugging the scoping","text":"<p>As mentioned above, unless you have a very boring and predictable code (which is a good thing!), due to how dynamic PHP is, scoping will almost guaranteed never work on the first and will require adjustments. To help with the process, there is two recommendations:</p> <ul> <li>Have an end-to-end test for your application. On in which you can easily swap from your regular binary, the PHAR and   the isolated PHAR. This will help to identify at which test there is an issue besides being able to easily guarantee   your application, shipped as a PHAR or not, is somewhat working.</li> <li>Make use of Box <code>--debug</code> option in the <code>compile</code> command. It dumps the code added to the PHAR in a <code>.box-dump</code>   directory. This allows you to more easily inspect, alter and test the code shipped in the PHAR. This way, you can   make sure the code shipped is working before worrying about whether that code is going to work inside a PHAR.</li> <li>Use the <code>process</code> command on a specific file to check the result and the effects of the configuration on it</li> </ul> <p></p> <p>\u00ab Optimize your PHAR \u2022 Docker support \u00bb</p>"},{"location":"configuration/","title":"Configuration","text":"<ol> <li>Base path</li> <li>Main</li> <li>Output</li> <li>Permissions</li> <li>Check requirements</li> <li>Including files<ol> <li>Force auto-discovery (<code>force-autodiscovery</code>)</li> <li>Files (<code>files</code> and <code>files-bin</code>)</li> <li>Directories (<code>directories</code> and <code>directories-bin</code>)</li> <li>Finder (<code>finder</code> and <code>finder-bin</code>)</li> <li>Blacklist (<code>blacklist</code>)</li> <li>Excluding the Composer files (<code>exclude-composer-files</code>)</li> <li>Excluding dev files (<code>exclude-dev-files</code>)</li> <li>Map (<code>map</code>)</li> </ol> </li> <li>Stub<ol> <li>Stub (<code>stub</code>)</li> <li>Alias (<code>alias</code>)</li> <li>Shebang (<code>shebang</code>)</li> <li>Banner (<code>banner</code>)</li> <li>Banner file (<code>banner-file</code>)</li> </ol> </li> <li>Forcing the timestamp (<code>timestamp</code>)</li> <li>Dumping the Composer autoloader (<code>dump-autoload</code>)</li> <li>Compactors (<code>compactors</code>)<ol> <li>Annotations (<code>annotations</code>)</li> <li>PHP-Scoper (<code>php-scoper</code>)</li> </ol> </li> <li>Compression algorithm (<code>compression</code>)</li> <li>Security<ol> <li>Signing algorithm (<code>algorithm</code>)</li> <li>The private key (<code>key</code>)</li> <li>The private key password (<code>key-pass</code>)</li> </ol> </li> <li>Metadata (<code>metadata</code>)</li> <li>Replaceable placeholders<ol> <li>Replacements (<code>replacements</code>)</li> <li>Replacement sigil (<code>replacement-sigil</code>)</li> <li>Datetime placeholder (<code>datetime</code>)</li> <li>Datetime placeholder format (<code>datetime-format</code>)</li> <li>Pretty git commit placeholder (<code>git</code>)</li> <li>Git commit placeholder (<code>git-commit</code>)</li> <li>Short git commit placeholder (<code>git-commit-short</code>)</li> <li>Git tag placeholder (<code>git-tag</code>)</li> <li>Git version placeholder (<code>git-version</code>)</li> </ol> </li> </ol> <p>The build command will build a new PHAR based on a variety of settings.</p> <p>This command relies on a configuration file for loading PHAR packaging settings. If a configuration file is not specified through the <code>--config|-c option</code>, one of the following files will be used (in order): <code>box.json</code>, <code>box.json.dist</code>. If no configuration file is found, Box will proceed with the default settings.</p> <p>The configuration file is a JSON object saved to a file. Note that all settings are optional. If a setting is set to <code>null</code>, then its default value will be picked and is strictly equivalent to not setting the value.</p> <pre><code>{\n    \"algorithm\": \"?\",\n    \"alias\": \"?\",\n    \"annotations\": \"?\",\n    \"banner\": \"?\",\n    \"banner-file\": \"?\",\n    \"base-path\": \"?\",\n    \"blacklist\": \"?\",\n    \"check-requirements\": \"?\",\n    \"chmod\": \"?\",\n    \"compactors\": \"?\",\n    \"compression\": \"?\",\n    \"datetime\": \"?\",\n    \"datetime-format\": \"?\",\n    \"directories\": \"?\",\n    \"directories-bin\": \"?\",\n    \"dump-autoload\": \"?\",\n    \"exclude-composer-files\": \"?\",\n    \"exclude-dev-files\": \"?\",\n    \"files\": \"?\",\n    \"files-bin\": \"?\",\n    \"finder\": \"?\",\n    \"finder-bin\": \"?\",\n    \"force-autodiscovery\": \"?\",\n    \"git\": \"?\",\n    \"git-commit\": \"?\",\n    \"git-commit-short\": \"?\",\n    \"git-tag\": \"?\",\n    \"git-version\": \"?\",\n    \"intercept\": \"?\",\n    \"key\": \"?\",\n    \"key-pass\": \"?\",\n    \"main\": \"?\",\n    \"map\": \"?\",\n    \"metadata\": \"?\",\n    \"output\": \"?\",\n    \"php-scoper\": \"?\",\n    \"replacement-sigil\": \"?\",\n    \"replacements\": \"?\",\n    \"shebang\": \"?\",\n    \"stub\": \"?\",\n    \"timestamp\": \"?\"\n}\n</code></pre>"},{"location":"configuration/#base-path-base-path","title":"Base-path (<code>base-path</code>)","text":"<p>The <code>base-path</code> (<code>string</code>|<code>null</code>) setting is used to specify where all of the relative file paths should resolve to. This does not, however, alter where the built PHAR will be stored (see: <code>output</code>).</p> <p>If set to <code>null</code> or not specified, the base path used is the directory containing the configuration file when a specific configuration file is given or the current working directory otherwise.</p>"},{"location":"configuration/#main-main","title":"Main (<code>main</code>)","text":"<p>The main (<code>string</code>|<code>false</code>|<code>null</code>) setting is used to specify the file (relative to <code>base-path</code>) that will be run when the PHAR is executed from the command line (To not confuse with the stub which is the PHAR bootstrapping file).</p> <p>When you have a main script file that can be used as a stub, you can disable the main script by setting it to false:</p> <pre><code>{\n    \"stub\": \"bin/acme.php\",\n    \"main\": false\n}\n</code></pre> <p>When the parameter is not given or set to <code>null</code>, Box tries to guess the binary of the application with the <code>composer.json</code> file. If the Composer <code>bin</code> is set, Box will pick the first value provided. Otherwise it will fallback on the PHAR default file used which is <code>index.php</code>.</p> <p>The main file contents is processed by the compactors as the other files.</p> <p>If the main file starts with a shebang line (<code>#!</code>), it will be automatically removed (the shebang line goes in the stub for a PHAR and is configured by the shebang setting).</p>"},{"location":"configuration/#output-output","title":"Output (<code>output</code>)","text":"<p>The output (<code>string</code>|<code>null</code>) setting specifies the file name and path of the newly built PHAR. If the value of the setting is not an absolute path, the path will be relative to the base path.</p> <p>If not provided or set to <code>null</code>, the default value used will based on the <code>main</code>. For example if the main file is <code>bin/acme.php</code> or <code>bin/acme</code> then the output will be <code>bin/acme.phar</code>.</p>"},{"location":"configuration/#permissions-chmod","title":"Permissions (<code>chmod</code>)","text":"<p>The chmod (<code>string</code>|<code>null</code>) setting is used to change the file permissions of the newly built PHAR. The string contains an octal value e.g. <code>0750</code>. By default the permissions of the created PHAR are unchanged so it should be <code>0644</code>.</p> <p>Check the following link for more on the possible values.</p>"},{"location":"configuration/#check-requirements-check-requirements","title":"Check requirements (<code>check-requirements</code>)","text":"<p>The check requirements setting (<code>boolean</code>|<code>null</code>, default <code>true</code>) is used to allow the PHAR to check for the application constraint before running. See more information about it here. If not set or set to <code>null</code>, then the requirement checker will be added. Note that this is true only if either the <code>composer.json</code>  or <code>composer.lock</code> could have been found.</p> <p>Warning</p> <p>this check is still done within the PHAR. As a result, if the required extension to open the PHAR due to the compression algorithm is not loaded, a hard failure will still appear: the requirement checker cannot be executed before that.</p>"},{"location":"configuration/#including-files","title":"Including files","text":"<p>There is two ways to include files. The first one is to not be picky about which files are shipped in the PHAR. If you omit any of the following options, all the files found. The base directory used to find the files is either the configuration file if one is used/specified or the current working directory otherwise. The <code>blacklist</code> setting can be used to filter out some files from that selection.</p> <p>If you however want a more granular selection, you can use a combination of the following options: <code>files</code>, <code>files-bin</code>, <code>directories</code>, <code>directories-bin</code>, <code>finder</code>, <code>finder-bin</code>, <code>blacklist</code>.</p> <p>If <code>directories</code> or <code>finder</code> is set (this includes empty values), Box will no longer try to guess which files should be included or not (unless you force the auto-discovery) and will give you full control on it instead.</p> <p>Note</p> <p>By default, dev dependencies are excluded for both strategies. However if you still which to include a file or directory from a dev dependency, you can do so by adding it via one of the following setting: <code>files</code>, <code>files-bin</code>, <code>directories</code> or <code>directories-bin</code>.</p> <p>Warning</p> <p>binary files are added before regular files. As a result if a file is found in both regular files and binary files, the regular file will take precedence.</p>"},{"location":"configuration/#force-auto-discovery-force-autodiscovery","title":"Force auto-discovery (<code>force-autodiscovery</code>)","text":"<p>The <code>force-autodiscovery</code> (<code>bool</code> default <code>false</code>) setting forces Box to attempt to find which files to include even though you are using the <code>directories</code> or <code>finder</code> setting.</p> <p>When Box tries to find which files to include, it may remove some files such as readmes or test files. If however you are using the <code>directories</code> or <code>finder</code>, Box will append the found files to the ones you listed.</p>"},{"location":"configuration/#files-files-and-files-bin","title":"Files (<code>files</code> and <code>files-bin</code>)","text":"<p>The <code>files</code> (<code>string[]</code>|<code>null</code> default <code>[]</code>) setting is a list of files paths relative to <code>base-path</code> unless absolute. Each file will be processed by the compactors, have their placeholder values replaced (see: <code>replacements</code>) and added to the PHAR.</p> <p>This setting is not affected by the <code>blacklist</code> setting.</p> <p><code>files-bin</code> is analogue to <code>files</code> except the files are added to the PHAR unmodified. This is suitable for the files such as images, those that contain binary data or simply a file you do not want to alter at all despite using compactors.</p> <p>Warning</p> <p>Symlinks are not followed/supported.</p>"},{"location":"configuration/#directories-directories-and-directories-bin","title":"Directories (<code>directories</code> and <code>directories-bin</code>)","text":"<p>The directories (<code>string[]</code>|<code>null</code> default <code>[]</code>) setting is a list of directory paths relative to <code>base-path</code>. All files will be processed by the compactors, have their placeholder values replaced (see: <code>replacements</code>) and added to the PHAR.</p> <p>Files listed in the <code>blacklist</code> will not be added to the PHAR.</p> <p><code>directories-bin</code> is analogue to <code>directories</code> except the files are added to the PHAR unmodified. This is suitable for the files such as images, those that contain binary data or simply a file you do not want to alter at all despite using compactors.</p> <p>Warning</p> <p>Setting the key <code>directories</code> (regardless of its value), will disable the file auto-discovery. If you want to keep it, check the force the auto-discovery setting.</p> <p>Warning</p> <p>By default Box excludes some files (e.g. dot files, readmes &amp; co). This is done in order to attempt to reduce the final PHAR size. There is at the moment no way to disable this (maybe this could be done via a new setting) but it remains possible to include them via <code>files</code>, <code>files-bin</code>, <code>directories-bin</code> or your own <code>finder</code> or <code>finder-bin</code>.</p> <p>Warning</p> <p>If some files are expected to be excluded from the <code>finder</code> (respectively <code>finder-bin</code>) but included in <code>directories</code> (respectively <code>directories-bin</code>), the those files will be included. The files included are a union of the directives.</p> <p>Warning</p> <p>Symlinks are not followed/supported.</p>"},{"location":"configuration/#finder-finder-and-finder-bin","title":"Finder (<code>finder</code> and <code>finder-bin</code>)","text":"<p>The finder (<code>object[]</code>|<code>null</code> default <code>[]</code>) setting is a list of JSON objects. Each object (key, value) tuple is a (method, arguments) of the Symfony Finder used by Box. If an array of values is provided for a single key, the method will be called once per value in the array.</p> <p>Note that the paths specified for the <code>in</code> method are relative to <code>base-path</code> and that the finder will account for the files registered in the <code>blacklist</code>.</p> <p><code>finder-bin</code> is analogue to <code>finder</code> except the files are added to the PHAR unmodified. This is suitable for the files such as images, those that contain binary data or simply a file you do not want to alter at all despite using compactors.</p> <p>Warning</p> <p>Setting the key <code>finder</code> (regardless of its value), will disable the file auto-discovery. If you want to keep it, check the force the auto-discovery setting.</p> <p>Warning</p> <p>If some files are expected to be excluded from the <code>finder</code> (respectively <code>finder-bin</code>) but included in <code>directories</code> (respectively <code>directories-bin</code>), the those files will be included. The files included are a union of the directives.</p> <p>Warning</p> <p>Symlinks are not followed/supported.</p> <p>Example:</p> <pre><code>{\n    \"finder\": [\n          {\n              \"notName\": \"/LICENSE|.*\\\\.md|.*\\\\.dist|Makefile|composer\\\\.json|composer\\\\.lock/\",\n              \"exclude\": [\n                  \"doc\",\n                  \"test\",\n                  \"test_old\",\n                  \"tests\",\n                  \"Tests\",\n                  \"vendor-bin\"\n              ],\n              \"in\": \"vendor\"\n          },\n          {\n              \"name\": \"composer.json\",\n              \"in\": \".\"\n          }\n    ]\n}\n</code></pre>"},{"location":"configuration/#blacklist-blacklist","title":"Blacklist (<code>blacklist</code>)","text":"<p>The <code>blacklist</code> (<code>string[]</code>|<code>null</code> default <code>[]</code>) setting is a list of files that must not be added. The files blacklisted are the ones found using the other available configuration settings: <code>files</code>, <code>files-bin</code>, <code>directories</code>, <code>directories-bin</code>, <code>finder</code>, <code>finder-bin</code>.</p> <p>Note that all the blacklisted paths are relative to the settings configured above. For example if you have the following file structure:</p> <pre><code>project/\n\u251c\u2500\u2500 box.json.dist\n\u251c\u2500\u2500 A/\n|   \u251c\u2500\u2500 A00\n|   \u2514\u2500\u2500 A01\n\u2514\u2500\u2500 B/\n    \u251c\u2500\u2500 B00\n    \u251c\u2500\u2500 B01\n    \u2514\u2500\u2500 A/\n        \u2514\u2500\u2500 BA00\n</code></pre> <p>With:</p> <pre><code>{\n    # other non file related settings\n\n    \"blacklist\": [\n        \"A\"\n    ]\n}\n</code></pre> <p>Box will try to collect all the files found in <code>project</code> (cf. Including files) but will exclude <code>A/</code> and `B/A resulting in the following files being collected:</p> <pre><code>project/\n\u251c\u2500\u2500 box.json.dist\n\u2514\u2500\u2500 B/\n    \u251c\u2500\u2500 B00\n    \u2514\u2500\u2500 B01\n</code></pre> <p>If you want a more granular blacklist leverage, use the Finders configuration instead.</p>"},{"location":"configuration/#excluding-the-composer-files-exclude-composer-files","title":"Excluding the Composer files (<code>exclude-composer-files</code>)","text":"<p>The <code>exclude-composer-files</code> (<code>boolean</code>|<code>null</code>, default <code>true</code>) setting will result in removing the Composer files <code>composer.json</code>, <code>composer.lock</code> and <code>vendor/composer/installed.json</code> if they are found regardless of whether or not they were found by Box alone or explicitly included.</p>"},{"location":"configuration/#excluding-dev-files-exclude-dev-files","title":"Excluding dev files (<code>exclude-dev-files</code>)","text":"<p>The <code>exclude-dev-files</code> (<code>bool</code> default <code>true</code>) setting will, when enabled, cause Box to attempt to exclude the files belonging to dev only packages. For example for the given project:</p> composer.json <pre><code>{\n    \"require\": {\n        \"beberlei/assert\": \"^3.0\"\n    },\n    \"require-dev\": {\n        \"bamarni/composer-bin-plugin\": \"^1.2\"\n    }\n}\n</code></pre> <p>The <code>vendor</code> directory will have <code>beberlei/assert</code> and <code>bamarni/composer-bin-plugin</code>. If <code>exclude-dev-files</code> is not disabled, the <code>bamarni/composer-bin-plugin</code> package will be removed from the PHAR.</p> <p>This setting will automatically be disabled when <code>dump-autoload</code> is disabled. Indeed, otherwise some files will not be shipped in the PHAR but may still appear in the Composer autoload classmap, resulting in an autoloading error.</p>"},{"location":"configuration/#map-map","title":"Map (<code>map</code>)","text":"<p>The map (<code>object[]</code> default <code>[]</code>) setting is used to change where some (or all) files are stored inside the PHAR. The key is a beginning of the relative path that will be matched against the file being added to the PHAR. If the key is a match, the matched segment will be replaced with the value. If the key is empty, the value will be prefixed to all paths (except for those already matched by an earlier key).</p> <p>For example, with the following configuration excerpt:</p> <pre><code>{\n  \"map\": [\n    { \"my/test/path\": \"src/Test\" },\n    { \"\": \"src/Another\" }\n  ]\n}\n</code></pre> <p>with the following files added to the PHAR:</p> <ul> <li><code>my/test/path/file.php</code></li> <li><code>my/test/path/some/other.php</code></li> <li><code>my/test/another.php</code></li> </ul> <p>the above files will be stored with the following paths in the PHAR:</p> <ul> <li><code>src/Test/file.php</code></li> <li><code>src/Test/some/other.php</code></li> <li><code>src/Another/my/test/another.php</code></li> </ul>"},{"location":"configuration/#stub","title":"Stub","text":"<p>The PHAR stub file is the PHAR bootstrapping file, i.e. the very first file executed whenever the PHAR is executed. It usually contains things like the PHAR configuration and executing the main script file.</p> <p>The default PHAR stub file can be used but Box also propose a couple of options to customize the stub used.</p>"},{"location":"configuration/#stub-stub","title":"Stub (<code>stub</code>)","text":"<p>The stub (<code>string</code>|<code>boolean</code>|<code>null</code> default <code>true</code>) setting is used to specify the location of a stub file or if one should be generated:</p> <ul> <li><code>string</code>: Path to the stub file will be used as is inside the PHAR</li> <li><code>true</code> (default): A new stub will be generated</li> <li><code>false</code>: The default stub used by the PHAR class will be used</li> </ul> <p>If a custom stub file is provided, none of the other options (<code>shebang</code>, <code>intercept</code> and <code>alias</code>) are used.</p>"},{"location":"configuration/#shebang-shebang","title":"Shebang (<code>shebang</code>)","text":"<p>The shebang (<code>string</code>|<code>false</code>|<code>null</code>) setting is used to specify the shebang line used when generating a new stub. By default, this line is used:</p> <pre><code>#!/usr/bin/env php\n</code></pre> <p>The shebang line can be removed altogether if set to <code>false</code>.</p>"},{"location":"configuration/#intercept-intercept","title":"Intercept (<code>intercept</code>)","text":"<p>The intercept (<code>boolean</code>|<code>null</code> default <code>false</code>) setting is used when generating a new stub. If setting is set to <code>true</code>, the Phar::interceptFileFuncs() method will be called in the stub.</p>"},{"location":"configuration/#alias-alias","title":"Alias (<code>alias</code>)","text":"<p>The <code>alias</code> (<code>string</code>|<code>null</code>) setting is used when generating a new stub to call the <code>Phar::mapPhar()</code>. This makes it easier to refer to files in the PHAR and ensure the access to internal files will always work regardless of the location of the PHAR on the file system.</p> <p>If no alias is provided, a generated unique name will be used for it in order to map the main file. Note that this may have undesirable effects if you are using the generated stub</p> <p>Example:</p> <pre><code>// .phar.stub\n\n#!/usr/bin/env php\n&lt;?php\n\nif (class_exists('Phar')) {\n    Phar::mapPhar('alias.phar');\n    require 'phar://' . __FILE__ . '/index.php';\n}\n\n__HALT_COMPILER(); ?&gt;\n\n\n// index.php\n&lt;?php\n\nif (!isset($GLOBALS['EXECUTE'])) {\n    $GLOBALS['EXECUTE'] = true;\n}\n\n// On the first execution, we require that other file while\n// on the second we will echo \"Hello world!\"\nif ($GLOBALS['EXECUTE']) {\n    require 'foo.php';\n} else {\n    echo 'Hello world!';\n}\n\n\n// foo.php\n&lt;?php\n\n$GLOBALS['EXECUTE'] = false;\n\n// Notice how we are using `phar://alias.phar` here. This will\n// always work. This allows you to not have to find where the file\n// is located in the PHAR neither finding the PHAR file path\nrequire 'phar://alias.phar/index.php';\n</code></pre> <p>If you are using the default stub, <code>Phar::setAlias()</code> will be used. Note however that this will behave slightly differently.</p> <p>Example:</p> <pre><code>&lt;?php\n\n$phar = new Phar('index.phar'); // Warning: creating a Phar instance results in *loading* the file. From this point, the\n                                // PHAR stub file has been loaded and as a result, if the PHAR had an alias the alias\n                                // will be registered.\n$phar-&gt;setAlias('foo.phar');\n$phar-&gt;addFile('LICENSE');\n\nfile_get_contents('phar://foo.phar/LICENSE'); // Will work both inside the PHAR but as well as outside as soon as the\n                                              // PHAR is loaded in-memory.\n</code></pre> <p>As you can see above, loading a PHAR which has an alias result in a non-negligible side effect. A typical case where this might be an issue can be illustrated with box itself. For its end-to-end test, the process is along the lines of:</p> <ul> <li> <ol> <li>Build a PHAR <code>box.phar</code> from the source code</li> </ol> </li> <li> <ol> <li>Build the PHAR <code>box.phar</code> from the source again but using the previous PHAR this time</li> </ol> </li> </ul> <p>If an alias <code>box-alias.phar</code> was registered for both for example, the building would fail. Indeed when building the second PHAR, the first PHAR is loaded which loads the alias <code>box-alias.phar</code>. When creating the second PHAR, box would try to register the alias <code>box-alias.phar</code> to that new PHAR but as the alias is already used, an error will be thrown.</p>"},{"location":"configuration/#banner-banner","title":"Banner (<code>banner</code>)","text":"<p>The banner (<code>string</code>|<code>string[]</code>|<code>false</code>|<code>null</code>) setting is the banner comment that will be used when a new stub is generated. The value of this setting must not already be enclosed within a comment block as it will be automatically done for you.</p> <p>For example <code>Custom banner</code> will result in the stub file:</p> <pre><code>/*\n * Custom banner\n */\n</code></pre> <p>An array of strings can be used for multilines banner:</p> <pre><code>{\n    \"banner\": [\n          \"This file is part of the box project.\",\n          \"\",\n          \"(c) Kevin Herrera &lt;kevin@herrera.io&gt;\",\n          \"Th\u00e9o Fidry &lt;theo.fidry@gmail.com&gt;\",\n          \"\",\n          \"This source file is subject to the MIT license that is bundled\",\n          \"with this source code in the file LICENSE.\"\n    ]\n}\n</code></pre> <p>Will result in:</p> <pre><code>/*\n * This file is part of the box project.\n *\n * (c) Kevin Herrera &lt;kevin@herrera.io&gt;\n *     Th\u00e9o Fidry &lt;theo.fidry@gmail.com&gt;\n *\n * This source file is subject to the MIT license that is bundled\n * with this source code in the file LICENSE.\n */\n</code></pre> <p>By default, the Box banner is used. If set to <code>false</code>, no banner at all will be used.</p> <p>The content of this value is discarded if <code>banner-file</code> is set.</p>"},{"location":"configuration/#banner-file-banner-file","title":"Banner file (<code>banner-file</code>)","text":"<p>The banner-file (<code>string</code>|<code>null</code> ignored by default) setting is like banner, except it is a path (relative to the base path) to the file that will contain the comment.</p> <p>Like banner, the comment must not already be enclosed in a comment block.</p> <p>If this parameter is set to a different value than <code>null</code>, then the value of <code>banner</code> will be discarded.</p>"},{"location":"configuration/#forcing-the-timestamp-timestamp","title":"Forcing the timestamp (<code>timestamp</code>)","text":"<p>The <code>timestamp</code> (<code>string</code>|<code>null</code>, default <code>null</code>) setting will result in Box forcing the timestamp of the PHAR. By default, the timestamp of the PHAR is the one at which the PHAR was built. It may be useful to fix it for reproducible builds.</p> <p>Warning</p> <p>Forcing the timestamp cannot be done when using an OpenSSL signature.</p>"},{"location":"configuration/#dumping-the-composer-autoloader-dump-autoload","title":"Dumping the Composer autoloader (<code>dump-autoload</code>)","text":"<p>The <code>dump-autoload</code> (<code>boolean</code>|<code>null</code>, default <code>true</code>) setting will result in Box dump the Composer autoload with the classmap authoritative mode and the <code>--no-dev</code> option which disables the <code>autoload-dev</code> rules. This is however done only if a <code>composer.json</code> file could be found. If a <code>composer.lock</code> file is found as well, the file <code>vendor/composer/installed.json</code> will be required too.</p> <p>The dumping of the autoloader will be ignored if the <code>composer.json</code> file could not be found.</p> <p>The autoloader is dumped at the end of the process to ensure it will take into account the eventual modifications done by the compactors process.</p>"},{"location":"configuration/#compactors-compactors","title":"Compactors (<code>compactors</code>)","text":"<p>The compactors (<code>string[]</code>|<code>null</code> default <code>[]</code>) setting is a list of file contents compacting classes that must be registered. A file compacting class is used to reduce the size of a specific file type. The following is a simple example:</p> <pre><code>&lt;?php\n\nnamespace Acme;\n\nuse KevinGH\\Box\\Compactor\\Compactor;\n\nclass MyCompactor implements Compactor\n{\n    /**\n     * {@inheritdoc}\n     */\n    public function compact(string $file, string $contents): string\n    {\n        if (preg_match('/\\.txt/', \\$file)) {\n            return trim($contents);\n        }\n\n        return $contents;\n    }\n}\n</code></pre> <p>The following compactors are included with Box:</p> <ul> <li><code>KevinGH\\Box\\Compactor\\Json</code>: compress JSON files</li> <li><code>KevinGH\\Box\\Compactor\\Php</code>: strip down classes from phpdocs &amp; comments</li> <li><code>KevinGH\\Box\\Compactor\\PhpScoper</code>: isolate the code using PHP-Scoper</li> </ul> <p>The effects of the compactors and replacement values can be tested with the <code>process</code> command \u2728.</p>"},{"location":"configuration/#annotations-annotations","title":"Annotations (<code>annotations</code>)","text":"<p>The annotations (<code>boolean</code>|<code>object</code>|<code>null</code> default <code>true</code>) setting is used to enable compacting annotations in PHP source code.</p> <p>This setting is only taken into consideration if the <code>KevinGH\\Box\\Compactor\\Php</code> compactor is enabled.</p> <p>By default, it removes all non real-like annotations from the PHP code. See the following example:</p> Original code <pre><code>&lt;?php\n\n/**\n * Function comparing the two given values\n *\n * @param int $x\n * @param int $y\n *\n * @return int\n *\n * @author Th\u00e9o Fidry\n * @LICENSE MIT\n *\n * @Acme(type = \"function\")\n */\nfunction foo($x, $y): int {\n    // Compare the two values\n    return $x &lt;=&gt; $y;\n}\n</code></pre> Compacted code <pre><code>&lt;?php\n\n/**\n@Acme(type=\"function\")\n\n\n\n\n\n\n\n\n\n\n*/\nfunction foo($x, $y): int {\n\n return $x &lt;=&gt; $y;\n}\n</code></pre> <p>Note that the empty line returns are on purpose: it is to keep the same line number for the files between your source code and the code bundled in the PHAR.</p> <p>If you wish to keep all annotations, you can disable the annotations like so:</p> <pre><code>{\n    \"annotations\": false\n}\n</code></pre> <p>For a more granular list, you can manually configure the list of annotations you wish to ignore:</p> <pre><code>{\n    \"annotations\": {\n        \"ignore\": [\n            \"author\",\n            \"package\",\n            \"version\",\n            \"see\"\n        ]\n    }\n}\n</code></pre>"},{"location":"configuration/#php-scoper-php-scoper","title":"PHP-Scoper (<code>php-scoper</code>)","text":"<p>The PHP-Scoper setting (<code>string</code>|<code>null</code> default <code>scoper.inc.php</code>) points to the path to the PHP-Scoper configuration file. For more documentation regarding PHP-Scoper, you can head to PHAR code isolation or PHP-Scoper official documentation.</p> <p>Note that this setting is used only if the compactor <code>KevinGH\\Box\\Compactor\\PhpScoper</code> is registered.</p>"},{"location":"configuration/#compression-algorithm-compression","title":"Compression algorithm (<code>compression</code>)","text":"<p>The compression (<code>string</code>|<code>null</code> default <code>'NONE'</code>) setting is the compression algorithm to use when the PHAR is built. The compression affects the individual files within the PHAR and not the PHAR as a whole (<code>Phar::compressFiles()</code>). The following is a list of the signature algorithms available:</p> <ul> <li><code>GZ</code> (the most efficient most of the time)</li> <li><code>BZ2</code></li> <li><code>NONE</code> (default)</li> </ul> <p>Warning</p> <p>Be aware that if compressed, the PHAR will required the appropriate extension (<code>zlib</code> for <code>GZ</code> and <code>bz2</code> for <code>BZ2</code>) to execute the PHAR. Without it, PHP will not be able to open the PHAR at all.</p>"},{"location":"configuration/#security","title":"Security","text":""},{"location":"configuration/#signing-algorithm-algorithm","title":"Signing algorithm (<code>algorithm</code>)","text":"<p>The algorithm (<code>string</code>|<code>null</code> default <code>SHA1</code>) setting is the signing algorithm to use when the PHAR is built (<code>Phar::setSignatureAlgorithm()</code>). The following is a list of the signature algorithms available:</p> <ul> <li><code>MD5</code></li> <li><code>SHA1</code></li> <li><code>SHA256</code></li> <li><code>SHA512</code></li> <li><code>OPENSSL</code> (deprecated)</li> </ul> <p>By default, PHARs are <code>SHA1</code> signed.</p> <p>The <code>OPENSSL</code> algorithm will require to provide a key.</p> <p>Warning</p> <p>The OpenSSL signature has been deprecated as of Box 4.4.0. If you are wondering why check out the signing best practices.</p>"},{"location":"configuration/#the-private-key-key","title":"The private key (<code>key</code>)","text":"<p>The key (<code>string</code>|<code>null</code> default <code>null</code>) setting is used to specify the path to the private key file. The private key file will be used to sign the PHAR using the <code>OPENSSL</code> signature algorithm (see Signing algorithm) and the setting will be completely ignored otherwise. If an absolute path is not provided, the path will be relative to the current working directory.</p>"},{"location":"configuration/#the-private-key-password-key-pass","title":"The private key password (<code>key-pass</code>)","text":"<p>The private key password  (<code>string</code>|<code>boolean</code>|<code>null</code> default <code>null</code>) setting is used to specify the pass-phrase for the private key. If a string is provided, it will be used as is as the pass-phrase. If <code>true</code> is provided, you will be prompted for the passphrase unless you are not in an interactive environment.</p> <p>This setting will be ignored if no key has been provided.</p>"},{"location":"configuration/#metadata-metadata","title":"Metadata (<code>metadata</code>)","text":"<p>Warning</p> <p>The metadata setting has been deprecated as of Box 4.6.0. See #1152.</p> <p>The metadata (<code>any</code> default none) setting can be any value. This value will be stored as metadata that can be retrieved from the built PHAR (Phar::getMetadata()).</p> <p>If you specify a callable (as a string), it will be evaluated without any arguments.</p> <p>For example, if you take the following code:</p> <pre><code>&lt;?php\n# callable_script.php\nclass MyCallbacks\n{\n    public static function generateMetadata()\n    {\n        return ['application_version' =&gt; '1.0.0-dev'];\n    }\n}\n</code></pre> <p>With the configuration excerpt:</p> <pre><code>{\n    \"metadata\": \"MyCallbacks::generateMetadata\"\n}\n</code></pre> <p>Then the <code>Phar::getMetadata()</code> will return <code>['application_version' =&gt; '1.0.0-dev']</code> array.</p> <p>Warning</p> <p>Your callable function must be readable by your autoloader.</p> <p>That means, for Composer, in previous example, we require to have such kind of declaration in your <code>composer.json</code> file.</p> <pre><code>{\n    \"autoload\": {\n        \"files\": [\"/path/to/your/callable_script.php\"]\n    }\n}\n</code></pre>"},{"location":"configuration/#replaceable-placeholders","title":"Replaceable placeholders","text":"<p>This feature allows you to set placeholders in your code which will be replaced by different values by Box when building the PHAR.</p> <p>For example, if you take the following code:</p> <pre><code>&lt;?php\n\nclass Application\n{\n    public function getVersion(): string\n    {\n        return '@git_commit_short@';\n    }\n}\n</code></pre> <p>With the configuration excerpt:</p> <pre><code>{\n    \"git-commit-short\": \"git_commit_short\"\n}\n</code></pre> <p>Then the actual code shipped in the PHAR will be:</p> <pre><code>&lt;?php\n\nclass Application\n{\n    public function getVersion(): string\n    {\n        return 'a6c5d93';\n    }\n}\n</code></pre> <p>The <code>@</code> is the default value of the sigil which is the placeholders delimited and <code>git-commit-short</code> is one of the built in placeholder. Box ships a few buit-in placeholders which you can find bellow, but you can also specify any replacement value via the <code>replacements</code> setting.</p> <p>The effects of the compactors and replacement values can be tested with the <code>process</code> command \u2728.</p>"},{"location":"configuration/#replacements-replacements","title":"Replacements (<code>replacements</code>)","text":"<p>The replacements (<code>object</code>|<code>null</code>, default <code>{}</code>) setting is a map of placeholders (as keys) and their values. The placeholders are replaced in all non-binary files with the specified values.</p> <p>For example:</p> <pre><code>{\n    \"replacements\": {\n        \"foo\": \"bar\"\n    }\n}\n</code></pre> <p>Will result in the string <code>@foo@</code> in your code to be replaced by <code>'bar'</code>. The delimiter <code>@</code> being the sigil.</p>"},{"location":"configuration/#replacement-sigil-replacement-sigil","title":"Replacement sigil (<code>replacement-sigil</code>)","text":"<p>The replacement sigil (<code>string</code>|<code>null</code> default <code>@</code>) is the character or chain of characters used to delimit the placeholders. See the @replacements setting for examples of placeholders.</p>"},{"location":"configuration/#datetime-placeholder-datetime","title":"Datetime placeholder (<code>datetime</code>)","text":"<p>The datetime (<code>string</code>|<code>null</code> default <code>null</code>) setting is the name of a placeholder value that will be replaced in all non-binary files by the current datetime. If no value is given (<code>null</code>) then this placeholder will be ignored.</p> <p>Example value the placeholder will be replaced with: <code>2015-01-28 14:55:23 CEST</code></p> <p>The format of the date used is defined by the <code>datetime-format</code> setting.</p>"},{"location":"configuration/#datetime-placeholder-format-datetime-format","title":"Datetime placeholder format (<code>datetime-format</code>)","text":"<p>The datetime format placeholder (<code>string</code>|<code>null</code>, default <code>Y-m-d H:i:s T</code>) setting accepts a valid PHP date format. It can be used to change the format for the <code>datetime</code> setting.</p>"},{"location":"configuration/#pretty-git-tag-placeholder-git","title":"Pretty git tag placeholder (<code>git</code>)","text":"<p>The git tag placeholder (<code>string</code>|<code>null</code> default <code>null</code>) setting is the name of a placeholder value that will be replaced in all non-binary files by the current git tag of the repository.</p> <p>Example of value the placeholder will be replaced with:</p> <ul> <li><code>2.0.0</code> on an exact tag match</li> <li><code>2.0.0@e558e33</code> on a commit following a tag</li> </ul>"},{"location":"configuration/#git-commit-placeholder-git-commit","title":"Git commit placeholder (<code>git-commit</code>)","text":"<p>The git commit (<code>string</code>|<code>null</code> default <code>null</code>) setting is the name of a placeholder value that will be replaced in all non-binary files by the current git commit hash of the repository.</p> <p>Example of value the placeholder will be replaced with: <code>e558e335f1d165bc24d43fdf903cdadd3c3cbd03</code></p>"},{"location":"configuration/#short-git-commit-placeholder-git-commit-short","title":"Short git commit placeholder (<code>git-commit-short</code>)","text":"<p>The short git commit (<code>string</code>|<code>null</code> default <code>null</code>) setting is the name of a placeholder value that will be replaced in all non-binary files by the current git short commit hash of the repository.</p> <p>Example of value the placeholder will be replaced with: <code>e558e33</code></p>"},{"location":"configuration/#git-tag-placeholder-git-tag","title":"Git tag placeholder (<code>git-tag</code>)","text":"<p>The git tag placeholder (<code>string</code>|<code>null</code> default <code>null</code>) setting is the name of a placeholder value that will be replaced in all non-binary files by the current git tag of the repository.</p> <p>Example of value the placeholder will be replaced with:</p> <ul> <li><code>2.0.0</code> on an exact tag match</li> <li><code>2.0.0-2-ge558e33</code> on a commit following a tag</li> </ul>"},{"location":"configuration/#git-version-placeholder-git-version","title":"Git version placeholder (<code>git-version</code>)","text":"<p>The git version (<code>string</code>|<code>null</code> default <code>null</code>) setting is the name of a placeholder value that will be replaced in all non-binary files by the one of the following (in order):</p> <ul> <li>The git repository's most recent tag.</li> <li>The git repository's current short commit hash.</li> </ul> <p>The short commit hash will only be used if no tag is available.</p> <p></p> <p>\u00ab Installation \u2022 Requirement Checker \u00bb</p>"},{"location":"docker/","title":"Docker support","text":"<p>Besides generating a PHAR, you may want to create a Docker image for your application. To do so, you can either:</p> <ul> <li>Directly generate the <code>Dockerfile</code> when generating the PHAR with the <code>--with-docker</code> option of the Box <code>compile</code>   command</li> <li>Generate the <code>Dockerfile</code> for a given PHAR with the Box <code>docker</code> command</li> </ul> <p>The command will attempt to generate a <code>Dockerfile</code> for your PHAR, leveraging the requirement checker. Once the file generated, you have free hands on it: you can either use it right away (you just need to run <code>$ docker build .</code> to create the docker image) or you can tweak it however you want.</p> <p>In your <code>Dockerfile</code> (generated by Box), you should see the following line:</p> <pre><code>RUN $(php -r '$extensionInstalled = array_map(\"strtolower\", \\get_loaded_extensions(false));$requiredExtensions = [\"zlib\", \"phar\", \"openssl\", \"pcre\", \"tokenizer\"];$extensionsToInstall = array_diff($requiredExtensions, $extensionInstalled);if ([] !== $extensionsToInstall) {echo \\sprintf(\"docker-php-ext-install %s\", implode(\" \", $extensionsToInstall));}echo \"echo \\\"No extensions\\\"\";')\n</code></pre> <p>This cryptic one-liner PHP script is about installing the required extensions for your application: it compares the ones your application requires with the ones already provided by the base PHP image, and then install them using the <code>docker-php-ext-install</code> command. It is however possible that this fails for various reason: the extension is not a known one, it cannot be installed the traditional way, it needs to be compiled with PHP... For all those cases (unless you have a better way to handle it in which case PRs are welcomed) you will have to dirty your hands and tweak the <code>Dockerfile</code> to your needs.</p> <p></p> <p>\u00ab PHAR code isolation \u2022 Symfony support \u00bb</p>"},{"location":"faq/","title":"FAQ","text":"<ol> <li>What is the canonical way to write a CLI entry file?</li> <li>The shebang</li> <li>The PHP_SAPI check</li> <li>Autoloading Composer</li> <li>Detecting that you are inside a PHAR</li> <li>Building a PHAR with Box as a dependency</li> </ol>"},{"location":"faq/#what-is-the-canonical-way-to-write-a-cli-entry-file","title":"What is the canonical way to write a CLI entry file?","text":"<p>A conventional CLI entry file looks like this (see bellow for further explanations):</p> <pre><code>#!/usr/bin/env php\n&lt;?php\n\ndeclare(strict_types=1);\n\nnamespace Acme;\n\nuse function in_array;\nuse const PHP_EOL;\nuse const PHP_SAPI;\nuse RuntimeException;\n\nif (false === in_array(PHP_SAPI, ['cli', 'phpdbg', 'embed'], true)) {\n    echo PHP_EOL.'This app may only be invoked from a command line, got \"'.PHP_SAPI.'\"'.PHP_EOL;\n\n    exit(1);\n}\n\n(static function (): void {\n    if (file_exists($autoload = __DIR__.'/../../../autoload.php')) {\n        // Is installed via Composer\n        include_once $autoload;\n\n        return;\n    }\n\n    if (file_exists($autoload = __DIR__.'/../vendor/autoload.php')) {\n        // Is installed locally\n        include_once $autoload;\n\n        return;\n    }\n\n    throw new RuntimeException('Unable to find the Composer autoloader.');\n})();\n\n// Execute the application\n</code></pre>"},{"location":"faq/#the-shebang","title":"The shebang","text":"<p>The shebang <code>#!/usr/bin/env php</code> is required to the auto-detection of the type of the script. This allows to use it as follows:</p> <pre><code>chmod +x bin/acme.php\n./bin/acme.php\nphp bin/acme.php # still works\n# Without the shebang line, you can only use the latter\n</code></pre> <p>In other words it is not necessary, but a nice to have if you want to make your file executable.</p>"},{"location":"faq/#the-php_sapi-check","title":"The PHP_SAPI check","text":"<p>For PHP, available SAPIs are: Apache2 (mod_php), FPM, CGI, FastCGI and CLI. There is a few other variants but those are the most commons ones. For more information, see the official PHP doc.</p> <p>So the following:</p> <pre><code>if (false === in_array(PHP_SAPI, ['cli', 'phpdbg', 'embed'], true)) {\n    echo PHP_EOL.'This app may only be invoked from a command line, got \"'.PHP_SAPI.'\"'.PHP_EOL;\n\n    exit(1);\n}\n</code></pre> <p>is purely ot make sure your CLI application is not executed in a non CLI context (for example via a web server). Doing so prevents you to have to worry about web-server related vulnerabilities such as HTTPoxy.</p> <ul> <li><code>cli</code> is the standard default you will get</li> <li><code>phpdbg</code> when executing PHP with PHPDBG</li> <li><code>embed</code> if you compile the PHP/ZE into another program</li> </ul>"},{"location":"faq/#autoloading-composer","title":"Autoloading Composer","text":"<p>When developing a CLI application, you generally only need to worry about your local autoloader:</p> <pre><code>include_once __DIR__.'/../vendor/autoload.php';\n</code></pre> <p>However, if the application is also published as a Composer package, then the autoloader may be found in a different location:</p> <pre><code>include_once __DIR__.'/../../../autoload.php';\n</code></pre> <p>In either cases however, it could be the autoloader file is missing (e.g. if the dependencies are not installed yet). So it is wise to wrap them in a <code>file_exist()</code> check and provide a user-friendly error when no autoloader could be found.</p>"},{"location":"faq/#detecting-that-you-are-inside-a-phar","title":"Detecting that you are inside a PHAR","text":"<p>The easiest way to know if your script is executed from within a PHAR is to run the following:</p> <pre><code>$isInPhar = '' !== Phar::running(false);\n</code></pre> <p>See Phar::running() for more information.</p>"},{"location":"faq/#building-a-phar-with-box-as-a-dependency","title":"Building a PHAR with Box as a dependency","text":"<p>If you need to include Box as part of your dependencies and include it within your PHAR, you will probably encounter the following issue when building your PHAR:</p> <pre><code>Could not dump the autoloader.\n[...]\nCould not scan for classes inside \"/path/to/vendor/humbug/php-scoper/vendor-hotfix/\" which does not appear to be a file nor a folder\n</code></pre> <p>This is because by default, Box does not include VCS or dot files which results in the directory <code>vendor/humbug/php-scoper/vendor-hotfix/</code> to be excluded (as it becomes an empty directory). To circumvent that, you will likely need:</p> <pre><code>{\n   \"directories\": [\"vendor/humbug/php-scoper/vendor-hotfix\"]\n}\n</code></pre> <p>Note that as a result you may want to use the <code>force-autodiscovery</code> setting.</p> <p></p> <p>\u00ab Symfony supports \u2022 Table of Contents \u00bb</p>"},{"location":"installation/","title":"Installation","text":"<ol> <li>Phive</li> <li>Composer</li> <li>Homebrew</li> <li>GitHub</li> <li>Docker</li> <li>shivammathur/setup-php (GitHub Actions)</li> </ol>"},{"location":"installation/#phive","title":"Phive","text":"<p>You can install Box with Phive</p> <pre><code>phive install humbug/box\n</code></pre> <p>To upgrade <code>box</code> use the following command:</p> <pre><code>phive update humbug/box\n</code></pre>"},{"location":"installation/#composer","title":"Composer","text":"<p>You can install Box with Composer:</p> <pre><code>composer global require humbug/box\n</code></pre> <p>If you cannot install it because of a dependency conflict or you prefer to install it for your project, we recommend you to take a look at bamarni/composer-bin-plugin. Example:</p> <pre><code>composer require --dev bamarni/composer-bin-plugin\ncomposer bin box require --dev humbug/box\n\nvendor/bin/box\n</code></pre>"},{"location":"installation/#homebrew","title":"Homebrew","text":"<p>To install box using Homebrew, you need to tap the box formula first</p> <pre><code>brew tap box-project/box\nbrew install box\n</code></pre> <p>The <code>box</code> command is now available to run from anywhere in the system:</p> <pre><code>box -v\n</code></pre> <p>To upgrade <code>box</code> use the following command:</p> <pre><code>brew upgrade box\n</code></pre>"},{"location":"installation/#github","title":"GitHub","text":"<p>You may download the Box PHAR directly from the GitHub release directly. You should however beware that it is not as secure as downloading it from the other mediums. Hence, it is recommended to check the signature when doing so:</p> <pre><code># Do adjust the URL if you need a release other than the latest\nwget -O box.phar \"https://github.com/box-project/box/releases/latest/download/box.phar\"\nwget -O box.phar.asc \"https://github.com/box-project/box/releases/latest/download/box.phar.asc\"\n\n# Check that the signature matches\ngpg --verify box.phar.asc box.phar\n\n# Check the issuer (the ID can also be found from the previous command)\ngpg --keyserver hkps://keys.openpgp.org --recv-keys 41539BBD4020945DB378F98B2DF45277AEF09A2F\n\nrm box.phar.asc\nchmod +x box.phar\n</code></pre>"},{"location":"installation/#docker","title":"Docker","text":"<p>The official docker image for the project is <code>boxproject/box</code>:</p> <pre><code>docker pull boxproject/box\n</code></pre>"},{"location":"installation/#shivammathursetup-php-github-actions","title":"<code>shivammathur/setup-php</code> (GitHub Actions)","text":"<p>Box is supported as a shivammathur/setup-php tool:</p> <pre><code>- name: Setup PHP with tools\n  uses: shivammathur/setup-php@v2\n  with:\n      php-version: '8.3'\n      tools: box\n</code></pre> <p></p> <p>\u00ab Table of Contents \u2022 Usage \u00bb</p>"},{"location":"optimizations/","title":"Optimize your PHAR","text":"<ol> <li>Review your files</li> <li>Compress your PHAR</li> <li>Optimize your code</li> </ol>"},{"location":"optimizations/#review-your-files","title":"Review your files","text":"<p>By default Box try to be smart about which files are required and will attempt to use only the necessary files. You can list the files of your PHAR with the box <code>info --list</code> command. It is however possible you want a finer control in which case you can adapt the included files thanks to the configuration options.</p> <p>All the files in the PHAR are loaded in-memory when executing a PHAR. As a result, the more content there is to load, the bigger the overhead will be and unlike your regular application, a PHAR will not benefit from the opcache optimisations. The difference should however be minimal unless you have dozens of thousands of files in which case you might either accept it, consider an alternative or contribute to the PHAR extension in order to optimise it.</p>"},{"location":"optimizations/#compress-your-phar","title":"Compress your PHAR","text":"<p>You can also greatly enhance the size of your PHAR by compressing it:</p> <ul> <li>The compression algorithm setting. It is very efficient, however note that a compressed PHAR   requires the <code>zip</code> PHP extension and has a (micro) overhead since PHP needs to uncompress the archive before using it</li> <li>Compactors can also help to compress some contents for example by removing the unnecessary comments and   spaces in PHP and JSON files.</li> </ul>"},{"location":"optimizations/#optimize-your-code","title":"Optimize your code","text":"<p>Another code performance optimisation that can be done is always use fully qualified symbols or use statements. For example the following:</p> <pre><code>&lt;?php\n\nnamespace Acme;\n\nuse stdClass;\nuse const BAR;\nuse function foo;\n\nnew stdClass();\nfoo(BAR);\n</code></pre> <p>Will be more performant than:</p> <pre><code>&lt;?php\n\nnamespace Acme;\n\nuse stdClass;\n\nnew stdClass();\nfoo(BAR);\n</code></pre> <p>Indeed in the second case, PHP is unable to know from where <code>foo</code> or <code>BAR</code> comes from. So it will first try to find <code>\\Acme\\foo</code> and <code>\\Acme\\BAR</code> and if not found will fallback to <code>\\foo</code> and <code>BAR</code>. This fallback lookup creates a minor overhead. Besides some functions such as <code>count</code> are optimised by opcache so using a fully qualified call <code>\\count</code> or importing it via a use statement <code>use function count</code> will be even more optimised.</p> <p>However you may not want to care and change your code for such micro optimisations. But if you do, know that isolating your PHAR code will transform every call into a fully qualified call whenever possible enabling that optimisation for your PHAR.</p> <p></p> <p>\u00ab Requirement Checker \u2022 PHAR code isolation \u00bb</p>"},{"location":"phar-signing/","title":"PHAR signing best practices","text":"<ol> <li>Built-in PHAR API<ol> <li>How to sign your PHAR</li> <li>How it works</li> <li>Why it is bad</li> </ol> </li> <li>How to (properly) sign your PHAR<ol> <li>Create a new GPG-key</li> <li>Manually signing</li> <li>Generate the encryption key</li> <li>Secure your encryption key</li> <li>Sign your PHAR</li> <li>Verifying the PHAR signature</li> </ol> </li> <li>Automatically sign in GitHub Actions</li> </ol> <p>There is two idiomatic ways to secure a PHAR:</p> <ul> <li>Using the built-in PHAR signing API (not recommended; read Why it is bad for the why).</li> <li>Signing the PHAR as any other generic binary (see Sign your PHAR).</li> </ul> <p>This doc entry goal is to show why the first method is to be avoided and how to do it \"the right way\".</p>"},{"location":"phar-signing/#built-in-phar-api","title":"Built-in PHAR API","text":""},{"location":"phar-signing/#how-to-sign-your-phar","title":"How to sign your PHAR","text":"<p>This is how a PHAR can be signed:</p> <pre><code>// See https://www.php.net/manual/en/phar.setsignaturealgorithm.php\n$phar-&gt;setSignatureAlgorithm($algo, $privateKey);\n</code></pre> <p>There is various algorithm available. The most \"secure\" one would be <code>Phar::OPENSSL</code> with an OpenSSL private key. For instance:</p> <pre><code>openssl genrsa -des3 -out acme-phar-private.pem 4096\n</code></pre> <pre><code>// E.g. $privateKeyPath = 'acme-phar-private.pem' with the example above\n$privateKey = file_get_contents($privateKeyPath);\n\n$resource = openssl_pkey_get_private($key, $privateKeyPassword);\nopenssl_pkey_export($resource, $private);\n$details = openssl_pkey_get_details($resource);\n\n$phar-&gt;setSignatureAlgorithm(Phar::OPENSSL, $private);\n\nfile_put_contents(\n    $phar-&gt;getPath().'.pubkey',\n    $details['key'],\n);\n</code></pre> <p>With the example above, you will end up with two files: your PHAR (e.g. <code>bin/command.phar</code>) and its public key (e.g. <code>bin/command.phar.pubkey</code>).</p>"},{"location":"phar-signing/#how-it-works","title":"How it works","text":"<p>To give more background on how PHAR archives are constructed, they are PHP files that contain a mixture of code and other binary data. It is analogous to the JAR files, and will require PHP to execute the PHARs. The content of a PHAR is as follows:</p> <ol> <li>A stub: a piece of code that handles the extraction of resources.</li> <li>A binary manifest which allows the interpreter to understand the file structure of the embedded contents that follow.</li> <li>The actual content of the archive.</li> <li>The signature makes up the last section of the file. It is a 4-byte signature flag which tells what signature type    was used and then another 4-byte constant marks the file as having a signature.</li> </ol> <p>When PHP later reads the archive, it can determine the signature and type by reading the end of the archive. This way, if the content of the PHAR has been tempered with, e.g. code was injected in the archive, PHP will see that the content of the archive does not match the signature of the PHAR and will bail out.</p>"},{"location":"phar-signing/#why-it-is-bad","title":"Why it is bad","text":"<p>There is a few downsides from this signing mechanisms:</p> <ul> <li>You cannot run the PHAR without its associated public key file laying right next to it. As a result, if you were to   move your PHAR under <code>/usr/local/bin</code>, the PHAR would no longer work due to the missing public key file.</li> <li>OpenSSL keys do not contain any identity information. So unless cleanly separated at distribution time, nobody knows   where the pub key came from or who generated it. Which (almost) kills the very idea of signing things.</li> </ul> <p>The real problem is the signature check itself. If the PHAR gets corrupted, maybe the signature got corrupted too. So there is ways to void the signature:</p> <ul> <li>Injects code before the stub, then this code will be executed before the signature check. The signature check can   still fail if the signature was not adjusted, but this might be too late.</li> <li>Replace the signature used. An OpenSSL one will only make it slightly harder as this requires to change an external   file (the public key), but in the context the attacker could inject code to the PHAR this is unlikely to be a real   prevention measure.</li> <li>The entire signature check can be disabled via the PHP ini setting <code>phar.require_hash</code>.</li> </ul> <p>So to conclude, this security mechanism CANNOT prevent modifications of the archive itself. It is NOT a reliable protection measure. It is merely a measure to prevent accidentally running a corrupted PHAR.</p> <p>The good news, there is a solution.</p>"},{"location":"phar-signing/#how-to-properly-sign-your-phar","title":"How to (properly) sign your PHAR","text":""},{"location":"phar-signing/#create-a-new-gpg-key","title":"Create a new GPG-key","text":"<p>The first step is to create a new GPG-key. You can either do that via a GUI or via the CLI like this:</p> <pre><code>gpg --gen-key\n</code></pre> <p>It will ask for some questions. It is recommended to use a passphrase (ideally generated and managed by a reputable password manager). In the end, you will end up with something like this:</p> <pre><code># $ gpg --gen-key output\npub   ed25519 2023-10-21 [SC] [expires: 2026-10-20]\n      96C8013A3CC293C465EE3FBB03B2F4DF7A20DF08\nuid                      Th\u00e9o Fidry &lt;theo.fidry+phar-signing-example@example.com&gt;\nsub   cv25519 2023-10-21 [E] [expires: 2026-10-20]\n</code></pre> <p>In this case the interesting part is <code>96C8013A3CC293C465EE3FBB03B2F4DF7A20DF08</code> which is the key ID. You can also check the list of your GPG keys like so:</p> <pre><code>gpg --list-secret-keys --keyid-format=long\n\n#\n# Other keys displayed too\n#\nsec   ed25519/03B2F4DF7A20DF08 2023-10-21 [SC] [expires: 2026-10-20]\n      96C8013A3CC293C465EE3FBB03B2F4DF7A20DF08\nuid                 [ultimate] Th\u00e9o Fidry &lt;theo.fidry+phar-signing-example@example.com&gt;\nssb   cv25519/765C0E3CCBC7D7D3 2023-10-21 [E] [expires: 2026-10-20]\n</code></pre> <p>Like above, you see the key ID <code>96C8013A3CC293C465EE3FBB03B2F4DF7A20DF08</code>.</p> <p>To make the key accessible for others we should now send it to a keyserver<sup>1</sup>.</p> <pre><code>gpg --keyserver keys.openpgp.org --send-key 96C8013A3CC293C465EE3FBB03B2F4DF7A20DF08\n</code></pre> <p>You can also already generate a revocation certificate for the key. Should the key be compromised you can then send the revocation certificate to the keyserver to invalidate the signing key.</p> <pre><code>gpg --output revoke-96C8013A3CC293C465EE3FBB03B2F4DF7A20DF08.asc --gen-revoke 96C8013A3CC293C465EE3FBB03B2F4DF7A20DF08\n</code></pre> <p>This will leave you with a revocation certificate in the file <code>revoke-96C8013A3CC293C465EE3FBB03B2F4DF7A20DF08.asc</code> which can be added to your password manager.</p>"},{"location":"phar-signing/#manually-signing","title":"Manually signing","text":"<p>For manually signing your PHAR (or any file actually), you will need to have an key containing both your public and private GPG key.</p>"},{"location":"phar-signing/#generate-the-encryption-key","title":"Generate the encryption key","text":"<p>In order to use the key to encrypt files, you need to first export it:</p> <pre><code>gpg --export --armor 96C8013A3CC293C465EE3FBB03B2F4DF7A20DF08 &gt; keys.asc\ngpg --export-secret-key --armor 96C8013A3CC293C465EE3FBB03B2F4DF7A20DF08 &gt;&gt; keys.asc\n</code></pre> <p>Warning</p> <p>That will leave the public and private key in a single file. Anyone that has that file can sign on your behalf! So keep that file secure at all times and make sure it never accidentally shows up in your git repository.</p>"},{"location":"phar-signing/#secure-your-encryption-key","title":"Secure your encryption key","text":"<p>If your goal is to save this encryption key somewhere, for example your repository, you should first encrypt it:</p> <pre><code>gpg --symmetric keys.asc\n</code></pre> <p>This will ask for a second passphrase. It is recommended to pick a different passphrase than for the key itself and ideally one generated and managed by a password manager.</p> <p>This leaves you with a file <code>keys.asc.gpg</code>. You can add this one to the repository and at this point you are probably better off deleting the <code>keys.asc</code> file. In order to do the actual signing, you will have to decrypt it again, but it is better to not keep that decrypted key around.</p>"},{"location":"phar-signing/#sign-your-phar","title":"Sign your PHAR","text":"<p>You first need to encrypt <code>keys.asc.gpg</code> into <code>keys.asc</code>:</p> <pre><code># If you are locally:\ngpg keys.asc.gpg\n# In another environment: CI or other. You should use an environment variable\n# or a temporary file to avoid printing the password in clear text.\necho $DECRYPT_KEY_PASSPHRASE | gpg --passphrase-fd 0 keys.asc.gpg\n# or:\ncat $(.decrypt-key-passphrase) | gpg --passphrase-fd 0 keys.asc.gpg\n</code></pre> <p>Import the decrypted key if it is not already present on the machine:</p> <pre><code>gpg --batch --yes --import keys.asc\n</code></pre> <p>Sign your file:</p> <pre><code>gpg \\\n   --batch \\\n   --passphrase=\"$GPG_KEY_96C8013A3CC293C465EE3FBB03B2F4DF7A20DF08_PASSPHRASE\" \\\n   --local-user 96C8013A3CC293C465EE3FBB03B2F4DF7A20DF08 \\\n   --armor \\\n   --detach-sign \\\n   bin/command.phar\n# Do not forget to remove keys.asc afterwards!\n</code></pre> <p>You will now have a file <code>bin/command.phar.asc</code>.</p> <p>When publishing your archive, you should publish both <code>bin/command.phar</code> and <code>bin/command.phar.asc</code>.</p>"},{"location":"phar-signing/#verifying-the-phar-signature","title":"Verifying the PHAR signature","text":"<p>First you should check the issuer's identity, usually it is provided from where you download it as part of the documentation:</p> <pre><code># If you are on the same machine as where you created the key, then this step is unnecessary.\n# You will need this however for when verifying a different key that you do not know of yet.\ngpg --keyserver hkps://keys.openpgp.org --recv-keys 96C8013A3CC293C465EE3FBB03B2F4DF7A20DF08\n</code></pre> <p>However not everyone exposes what is their GPG key ID. So sometimes to avoid bad surprises, you can look up for similar issuers to the key ID given by the <code>.asc</code>:</p> <pre><code># Verify the signature\ngpg --verify bin/command.phar.asc bin/command.phar\n\n# Example of output:\ngpg: Signature made Sat 21 Oct 16:58:05 2023 CEST\ngpg:                using EDDSA key 96C8013A3CC293C465EE3FBB03B2F4DF7A20DF08\ngpg: Good signature from \"Th\u00e9o Fidry &lt;theo.fidry+phar-signing-example@example.com&gt;\" [ultimate]\n</code></pre> <p>If the key ID was not provided before, you can try to look it up to check it was properly registered to a keyserver:</p> <pre><code>gpg --keyserver https://keys.openpgp.org --search-keys \"theo.fidry+phar-signing-example@example.com\"\n</code></pre> <p>Info</p> <p>Also note that when dealing with PHARs, the above steps are automatically done for you by PHIVE.</p>"},{"location":"phar-signing/#automatically-sign-in-github-actions","title":"Automatically sign in GitHub Actions","text":"<p>The first step is to add environment secrets to your repository:</p> <pre><code>gpg --export-secret-key --armor 96C8013A3CC293C465EE3FBB03B2F4DF7A20DF08\n# Paste the content into a secret environment variable\nGPG_KEY_96C8013A3CC293C465EE3FBB03B2F4DF7A20DF08\n\n# Add the corresponding passphrase enviroment variable:\nGPG_KEY_96C8013A3CC293C465EE3FBB03B2F4DF7A20DF08_PASSPHRASE\n</code></pre> <p>Then you need to:</p> <ul> <li>Build your PHAR</li> <li>Import the GPG key</li> <li>Sign your PHAR</li> <li>Publish your PHAR</li> </ul> <p>I highly recommend to build your PHAR as part of your regular workflows. Then the other steps can be enable on release only. The following is an example of GitHub workflow:</p> <pre><code># .github/workflows/release.yaml\nname: Release\n\non:\n    push:\n        branches: [ main ]\n    pull_request: ~\n    schedule:\n        # Do not make it the first of the month and/or midnight since it is a very busy time\n        - cron: \"* 10 6 * *\"\n    release:\n        types: [ created ]\n\n# See https://stackoverflow.com/a/72408109\nconcurrency:\n    group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}\n    cancel-in-progress: true\n\njobs:\n    build-phar:\n        runs-on: ubuntu-latest\n        name: Build PHAR\n        steps:\n            -   name: Checkout\n                uses: actions/checkout@v3\n                with:\n                    fetch-depth: 0\n\n            -   name: Setup PHP\n                uses: shivammathur/setup-php@v2\n                with:\n                    php-version: '8.1'\n                    ini-values: phar.readonly=0\n                    tools: composer\n                    coverage: none\n\n            -   name: Install Composer dependencies\n                uses: ramsey/composer-install@v2\n\n            -   name: Build PHAR\n                run: ...\n\n            # Smoke test.\n            # It is recommended ot have some sorts of tests for your PHAR.\n            -   name: Ensure the PHAR works\n                run: bin/command.phar --version\n\n            # The following section is done only for releases\n            -   name: Import GPG key\n                if: github.event_name == 'release'\n                uses: crazy-max/ghaction-import-gpg@v5\n                with:\n                    gpg_private_key: ${{ secrets.GPG_KEY_96C8013A3CC293C465EE3FBB03B2F4DF7A20DF08 }}\n                    passphrase: ${{ secrets.GPG_KEY_96C8013A3CC293C465EE3FBB03B2F4DF7A20DF08_PASSPHRASE }}\n\n            -   name: Sign the PHAR\n                if: github.event_name == 'release'\n                run: |\n                    gpg --local-user 96C8013A3CC293C465EE3FBB03B2F4DF7A20DF08 \\\n                        --batch \\\n                        --yes \\\n                        --passphrase=\"${{ secrets.GPG_KEY_96C8013A3CC293C465EE3FBB03B2F4DF7A20DF08_PASSPHRASE }}\" \\\n                        --detach-sign \\\n                        --output bin/command.phar.asc \\\n                        bin/command.phar\n\n            -   name: Upload PHAR to the release\n                uses: softprops/action-gh-release@v1\n                with:\n                   token: ${{ secrets.GITHUB_TOKEN }}\n                   files: |\n                      box.phar\n                      box.phar.asc\n</code></pre> <p>A more complete real-life example can be found in the Box release workflow.</p> <p></p> <p>\u00ab Reproducible build \u2022 FAQ \u00bb</p> <p>Credits:</p> <ul> <li>Andreas Heigl, January 19, 2017, Encrypt a build-result \u2013 automaticaly</li> <li>Arne Blankerts</li> <li>Jeff Channell, July 13, 2017, Code Injection in Signed PHP Archives (Phar)</li> </ul> <ol> <li> <p>There is several OpenPGP Keyservers. It is recommended to push your keys to keys.openpgp.org at least, but you can also push it to other servers if you wish to.\u00a0\u21a9</p> </li> </ol>"},{"location":"reproducible-builds/","title":"Reproducible builds","text":"<ol> <li>Creating a reproducible PHAR</li> <li>PHP-Scoper</li> <li>Composer<ol> <li>Composer root version</li> <li>Composer autoload suffix</li> </ol> </li> <li>Box<ol> <li>PHAR alias</li> <li>Requirement Checker</li> <li>Box banner</li> <li>Timestamp</li> </ol> </li> <li>Usages</li> </ol> <p>When building a PHAR, you sometimes want to have reproducible builds, i.e. no matter how many times you build the PHAR, as long as the source content is identical, then the resulting PHAR should not change.</p> <p>Whilst this sounds like a good idea and easy at first, it is not the default behaviour. Indeed there is a number of things that are generated and will make the resulting PHAR different, for example the Composer autoloader classname, or the scoping prefix if you are using PHP-Scoper.</p> <p>This documentation aims at walking you through the common elements to adjust in order to achieve reproducible builds. This is not an exhaustive piece of documentation as it will also depends on your own application too.</p>"},{"location":"reproducible-builds/#creating-a-reproducible-phar","title":"Creating a reproducible PHAR","text":""},{"location":"reproducible-builds/#php-scoper","title":"PHP-Scoper","text":"<p>If you are using the PHP-Scoper compactor, you will need to define a fixed prefix as otherwise a random one is generated.</p> <p>See the PHP-Scoper prefix configuration doc.</p>"},{"location":"reproducible-builds/#composer","title":"Composer","text":""},{"location":"reproducible-builds/#composer-root-version","title":"Composer root version","text":"<p>By default, the git commit of the current version is included in some places in the Composer generated files. At the time of writing, the current git reference can be found in <code>vendor/composer/installed.{json|php}</code> with the path <code>root.reference</code>.</p> <p>This is not ideal as the content of the PHAR could be identical for two different git commits. In order to get rid of this problem, you can leverage the <code>COMPOSER_ROOT_VERSION</code>. Either by exporting it or passing it to Box when compiling it:</p> <pre><code>COMPOSER_ROOT_VERSION=1.0.0-dev box compile\n</code></pre>"},{"location":"reproducible-builds/#composer-autoload-suffix","title":"Composer autoload suffix","text":"<p>By default, Box will dump the Composer autoloader which usually results in a different autoloader classname. There is exceptions to this, for example Composer tend to try to keep the known suffix if one already exist, but it is an exotic case that is not recommended to rely on. For this reason you need to configure the Composer autoload prefix:</p> <pre><code>composer config autoloader-suffix AppChecksum\n</code></pre> <p>Or configure it directly in your <code>composer.json</code>:</p> <pre><code>{\n    \"config\": {\n        \"autoloader-suffix\": \"AppChecksum\"\n    }\n}\n</code></pre>"},{"location":"reproducible-builds/#box","title":"Box","text":""},{"location":"reproducible-builds/#phar-alias","title":"PHAR Alias","text":"<p>By default, Box generates a random PHAR alias so you need to set a fixed value, e.g. <code>my-app-name</code>.</p> <p>See the Box alias setting.</p> <p>The output (<code>string</code>|<code>null</code>) setting specifies the file name and path of the newly built PHAR. If the value of the setting is not an absolute path, the path will be relative to the base path.</p> <p>If not provided or set to <code>null</code>, the default value used will based on the <code>main</code>. For example if the main file is <code>bin/acme.php</code> or <code>bin/acme</code> then the output will be <code>bin/acme.phar</code>.</p>"},{"location":"reproducible-builds/#requirement-checker","title":"Requirement Checker","text":"<p>By default, Box includes its Requirement Checker. It will not change from a PHAR to another, so this step should be skippable. However, the RequirementChecker shipped does change based on the Box version. I.e. building your PHAR with Box 4.3.8 will result in a different\u2020 requirement checker shipped than the one in 4.4.0.</p> <p>\u2020: By different is meant the checksum is different. The behaviour and code may be the exact same. The most likely difference will be the namespace.</p> <p>Note that this may change in the future: https://github.com/box-project/box/issues/1075.</p>"},{"location":"reproducible-builds/#box-banner","title":"Box banner","text":"<p>By default, Box generates a banner. This banners includes the Box version so building the same PHAR with two different Box versions will result in a different PHAR signature.</p>"},{"location":"reproducible-builds/#timestamp","title":"Timestamp","text":"<p>The files unix timestamp are part of the PHAR signature, hence if they have a different timestamp (which they do as when you add a PHAR to a file, it is changed to the time at when you added it).</p> <p>To fix this, you can leverage configure the timestamp.</p>"},{"location":"reproducible-builds/#usages","title":"Usages","text":"<p>Deterministic builds are a highly desirable property to prevent targeted malware attacks. They also make it easier to detect if there is any real change. As non-exhaustive examples in the wild: Composer and PHPStan.</p> <p>Another benefit of such builds is that it makes it easier to know if there was any change. You can know if two PHARs are identical by using the <code>box diff</code> command, or extract the signature out of the <code>box info:signature</code> command:</p> <pre><code>box info:signature app.phar\n</code></pre> <p>And re-use that signature later for comparison. You will loose the ability to do a detailed diff between the two PHARs, but it is enough to know if the PHARs are identical or not.</p> <p></p> <p>\u00ab Symfony support \u2022 PHAR signing best practicies \u00bb</p>"},{"location":"requirement-checker/","title":"Requirements checker","text":"<ol> <li>Configuration<ol> <li>PHP version requirements</li> <li>Extension configuration requirements</li> <li>Polyfills</li> </ol> </li> <li>Integration with a custom stub</li> </ol> <p>Unlike when installing a library with Composer, no constraint check is done by default with a PHAR. As a result, if you are using a PHAR of an application compatible with PHP 8.2 in PHP 7.4 or a PHP environment which does not have a required extension, it will simply break with a non-friendly error.</p> <p>By default, when building your PHAR, Box will look up for the PHP versions and extensions required to execute your application according to your <code>composer.json</code> and <code>composer.lock</code> files and ship a micro (~280KB uncompressed and &gt;40KB compressed) requirements checker which will be executed when starting your PHAR.</p> <p>The following are screenshots of the output when an error occurs (left) in a non-quiet verbosity and when all requirements are passing on the right in debug verbosity.</p> <p> </p> <p>Warning</p> <p>this check is still done within the PHAR. As a result, if the required extension to open the PHAR  due to the compression algorithm is not loaded, a hard failure will still appear:  the requirement checker cannot be executed before that.</p>"},{"location":"requirement-checker/#configuration","title":"Configuration","text":"<p>Box will retrieve all the (non-dev) requirements including the ones of the dependencies if there is any. When a <code>composer.lock</code> file is present, it will take the information from it. If not found, it will fallback on the <code>composer.json</code> but that it will not be able to retrieve any information regarding the dependencies requirements in this case.</p> <p>This behaviour can be forcefully enabled or disabled via the check requirements setting.</p>"},{"location":"requirement-checker/#php-version-requirements","title":"PHP version requirements","text":"<p>To register a minimal PHP version required by your application, you can register it as a requirement:</p> <pre><code>{\n    \"require\": {\n        \"php\": \"^7.2\"    \n    }\n}\n</code></pre> <p>Note that configuring the application to run in a specific version will not affect it. So in the following example:</p> <pre><code>{\n    \"require\": {\n        \"php\": \"^7.1\"    \n    },\n    \"config\": {\n        \"platform\": {\n            \"php\": \"7.1.10\"\n        }\n    }\n}\n</code></pre> <p>Composer will emulate PHP 7.1.10 environment. This makes sure that when installing the dependencies, they will be compatible with 7.1.10+. It will however not affect the application requirements and as a result Box will pick <code>^7.1</code> as the PHP requirement.</p>"},{"location":"requirement-checker/#extension-configuration-requirements","title":"Extension configuration requirements","text":"<p>To register an extension, you can specify it like so:</p> <pre><code>{\n    \"require\": {\n        \"ext-mbstring\": \"*\"    \n    }\n}\n</code></pre> <p>Note that although you can specify a specific version for the extension requirements, Box does not currently support it and will simply understand that the given extension is required regardless of the version specified.</p>"},{"location":"requirement-checker/#polyfills","title":"Polyfills","text":"<p>Box supports the following polyfills:</p> <ul> <li><code>symfony/polyfill-&lt;extension-name&gt;</code> for any extension</li> <li>paragonie/sodium_compat for the <code>libsodium</code> extension</li> <li>phpseclib/mcrypt_compat for the <code>mcrypt</code> extension</li> </ul> <p>For example, if you have the following configuration:</p> <pre><code>{\n    \"require\": {\n        \"ext-mbstring\": \"*\",\n        \"symfony/polyfill-mbstring\": \"^1.0\" \n    }\n}\n</code></pre> <p>Then the <code>mbstring</code> extension will not be required since its polyfill has been found.</p>"},{"location":"requirement-checker/#integration-with-a-custom-stub","title":"Integration with a custom stub","text":"<p>If you are using your own stub instead of the Box autogenerated one, you can still require the requirement checker manually. When building the PHAR, Box will add the requirement checker in the <code>.box</code> directory. As a result, you can require the requirement checker script <code>.box/check_requirements.php</code> like so:</p> <pre><code>// Stub file\n// Example where the PHAR used has the alias `acme.phar`\n\nrequire 'phar://acme.phar/.box/check_requirements.php';\n</code></pre> <p>The requirement checker works down to PHP 7.2.5+. If however you are including it after your custom code which is not PHP 7.2.5+ compatible, it will fail before the requirements are being checked.</p>"},{"location":"requirement-checker/#skipping-the-requirement-checker","title":"Skipping the requirement checker","text":"<p>When the requirement checker is shipped, you can always skip it by setting the environment variable <code>BOX_REQUIREMENT_CHECKER</code> to <code>0</code>. For example if you are using the <code>box.phar</code> which ships a requirement checker and want to skip it, you can run:</p> <pre><code>BOX_REQUIREMENT_CHECKER=0 php acme.phar \n</code></pre>"},{"location":"requirement-checker/#logging-to-stdout","title":"Logging to stdout","text":"<p>Since version 3.17.0, box logs the requirements checker output to <code>stderr</code> per default (see: #678). The requirements checker can be configured to output to <code>stdout</code> instead by setting <code>BOX_REQUIREMENTS_CHECKER_LOG_TO_STDOUT=1</code>:</p> <pre><code>BOX_REQUIREMENTS_CHECKER_LOG_TO_STDOUT=1 php acme.phar\n</code></pre> <p></p> <p>\u00ab Configuration \u2022 Optimize your PHAR \u00bb</p>"},{"location":"symfony/","title":"Symfony support","text":"<ol> <li>Project files</li> <li>Project directory</li> <li>Cache</li> </ol> <p>Examples of Symfony applications can be found in the project under <code>fixtures/build/dir012</code> (Symfony5) and <code>fixtures/build/dir018</code> (Symfony6 with the Runtime component).</p> <p>They may slightly vary to what you want to do since they are here for testing purposes, but they should be good enough to show-case a working scenario if this doc does not prove to be enough.</p>"},{"location":"symfony/#project-files","title":"Project files","text":"<p>When working with a Symfony project, you usually have a few files that are necessary for the application to work but cannot be inferred from Composer. A non-exhaustive list: <code>.env</code>, <code>public</code>, <code>config</code>, <code>var</code>.</p> <p>As a result, you will likely need to add them via <code>directories</code>, <code>files</code> or their <code>*-bin</code> variant which may force you to use the <code>force-autodiscovery</code> setting. For more information you can find check the Including files doc.</p>"},{"location":"symfony/#project-directory","title":"Project directory","text":"<p>Symfony 5.1+ defines the \"project dir\" as the directory where the composer.json file is. Because box deletes it during PHAR compilation, you need to redefine it in your Kernel. It is usually located in <code>src/Kernel.php</code> and can be defined as follow:</p> <pre><code>&lt;?php\n\nclass Kernel extends BaseKernel\n{\n...\n    public function getProjectDir()\n    {\n        return __DIR__.'/../';\n    }\n}\n</code></pre>"},{"location":"symfony/#cache","title":"Cache","text":"<p>What makes Symfony a bit special for shipping it into a PHAR is its compilation step. Indeed, the Symfony container can be dumped depending on multiple parameters such the application environment, whether it is in debug mode or not and if the cache is fresh.</p> <p>A PHAR however is a readonly only environment, which means the container cannot be dumped once inside the PHAR. To prevent the issue, you need to make sure of the following:</p> <ul> <li>The cache is warmed up before being shipped within the PHAR</li> <li>The application within the PHAR is running in production mode</li> </ul> <p>To achieve this with the least amount of changes is to:</p> <ul> <li>Create the <code>.env.local.php</code> file by running the following command:</li> </ul> <pre><code>composer dump-env prod\n</code></pre> <p>This will ensure when loading the variables that your application is in production mode.</p> <ul> <li>Change the following part of the <code>composer.json</code> file:</li> </ul> <pre><code>\"scripts\": {\n    \"auto-scripts\": {\n        \"cache:clear\": \"symfony-cmd\",\n        \"assets:install %PUBLIC_DIR%\": \"symfony-cmd\"\n    },\n    \"post-install-cmd\": [\n        \"@auto-scripts\"\n    ],\n    \"post-update-cmd\": [\n        \"@auto-scripts\"\n    ]\n},\n</code></pre> <p>For:</p> <pre><code>\"scripts\": {\n    \"auto-scripts\": {\n        \"cache:clear\": \"symfony-cmd\"\n    },\n    \"post-autoload-dump\": [\n        \"@auto-scripts\"\n    ]\n},\n</code></pre> <p>I.e.:</p> <ul> <li>You skip the installation of assets (which you shouldn't need in the context of a CLI application)</li> <li>Trigger the auto-scripts, which includes the cache warming phase, on the Composer dump-autoload event</li> </ul> <p>This last part takes advantage of Box dumping the autoloader by default.</p> <p></p> <p>\u00ab Docker support \u2022 Reproducible build \u00bb</p>"},{"location":"usage/","title":"Usage","text":"<p>Creating a PHAR should be as simple as running <code>box compile</code> (no config required!). It will however assume some defaults that you might want to change. Box will by default be looking in order for the files <code>box.json</code> and <code>box.json.dist</code> in the current working directory. A basic configuration could be for example changing the PHAR permissions:</p> <pre><code>{\n    \"chmod\": \"0700\"\n}\n</code></pre> <p>You can then find more advanced configuration settings in the configuration documentation. For more information on which command or options is available, you can run:</p> <pre><code>box help\n</code></pre> <p></p> <p>\u00ab Installation \u2022 Configuration \u00bb</p>"}]}
<?php

declare(strict_types=1);

/*
 * This file is part of the box project.
 *
 * (c) Kevin Herrera <kevin@herrera.io>
 *     Th√©o Fidry <theo.fidry@gmail.com>
 *
 * This source file is subject to the MIT license that is bundled
 * with this source code in the file LICENSE.
 */

namespace KevinGH\Box;

use Assert\Assertion;
use Closure;
use DateTimeImmutable;
use Herrera\Annotations\Tokenizer;
use Herrera\Box\Compactor\Php as LegacyPhp;
use Humbug\PhpScoper\Configuration as PhpScoperConfiguration;
use InvalidArgumentException;
use KevinGH\Box\Compactor\Php;
use KevinGH\Box\Compactor\PhpScoper as PhpScoperCompactor;
use KevinGH\Box\Composer\ComposerConfiguration;
use KevinGH\Box\Json\Json;
use KevinGH\Box\PhpScoper\SimpleScoper;
use Phar;
use RuntimeException;
use Seld\JsonLint\ParsingException;
use SplFileInfo;
use stdClass;
use Symfony\Component\Finder\Finder;
use Symfony\Component\Process\Process;
use function array_filter;
use function array_key_exists;
use function array_map;
use function array_merge;
use function array_unique;
use function file_exists;
use function Humbug\PhpScoper\create_scoper;
use function is_file;
use function is_readable;
use function iter\chain;
use function iter\fn\method;
use function iter\map;
use function iter\toArray;
use function iterator_to_array;
use function KevinGH\Box\FileSystem\canonicalize;
use function KevinGH\Box\FileSystem\file_contents;
use function KevinGH\Box\FileSystem\longest_common_base_path;
use function KevinGH\Box\FileSystem\make_path_absolute;
use function KevinGH\Box\FileSystem\make_path_relative;
use function preg_match;
use function substr;
use function uniqid;

/**
 * @private
 */
final class Configuration
{
    private const DEFAULT_ALIAS = 'test.phar';
    private const DEFAULT_MAIN_SCRIPT = 'index.php';
    private const DEFAULT_DATETIME_FORMAT = 'Y-m-d H:i:s';
    private const DEFAULT_REPLACEMENT_SIGIL = '@';
    private const DEFAULT_SHEBANG = '#!/usr/bin/env php';
    private const DEFAULT_BANNER = <<<'BANNER'
Generated by Humbug Box.

@link https://github.com/humbug/box
BANNER;
    private const FILES_SETTINGS = [
        'files',
        'files-bin',
        'directories',
        'directories-bin',
        'finder',
        'finder-bin',
    ];
    private const PHP_SCOPER_CONFIG = 'scoper.inc.php';

    private $file;
    private $fileMode;
    private $alias;
    private $basePath;
    private $composerJson;
    private $composerLock;
    private $files;
    private $binaryFiles;
    private $compactors;
    private $compressionAlgorithm;
    private $mainScriptPath;
    private $mainScriptContents;
    private $map;
    private $fileMapper;
    private $metadata;
    private $tmpOutputPath;
    private $outputPath;
    private $privateKeyPassphrase;
    private $privateKeyPath;
    private $isPrivateKeyPrompt;
    private $processedReplacements;
    private $shebang;
    private $signingAlgorithm;
    private $stubBannerContents;
    private $stubBannerPath;
    private $stubPath;
    private $isInterceptFileFuncs;
    private $isStubGenerated;
    private $checkRequirements;

    /**
     * @param null|string     $file
     * @param null|string     $alias
     * @param string          $basePath              Utility to private the base path used and be able to retrieve a path relative to it (the base path)
     * @param null[]|string[] $composerJson
     * @param null[]|string[] $composerLock
     * @param SplFileInfo[]   $files                 List of files
     * @param SplFileInfo[]   $binaryFiles           List of binary files
     * @param Compactor[]     $compactors            List of file contents compactors
     * @param null|int        $compressionAlgorithm  Compression algorithm constant value. See the \Phar class constants
     * @param null|int        $fileMode              File mode in octal form
     * @param string          $mainScriptPath        The main script file path
     * @param string          $mainScriptContents    The processed content of the main script file
     * @param MapFile         $fileMapper            Utility to map the files from outside and inside the PHAR
     * @param mixed           $metadata              The PHAR Metadata
     * @param string          $tmpOutputPath
     * @param string          $outputPath
     * @param null|string     $privateKeyPassphrase
     * @param null|string     $privateKeyPath
     * @param bool            $isPrivateKeyPrompt    If the user should be prompted for the private key passphrase
     * @param array           $processedReplacements The processed list of replacement placeholders and their values
     * @param null|string     $shebang               The shebang line
     * @param int             $signingAlgorithm      The PHAR siging algorithm. See \Phar constants
     * @param null|string     $stubBannerContents    The stub banner comment
     * @param null|string     $stubBannerPath        The path to the stub banner comment file
     * @param null|string     $stubPath              The PHAR stub file path
     * @param bool            $isInterceptFileFuncs  Whether or not Phar::interceptFileFuncs() should be used
     * @param bool            $isStubGenerated       Whether or not if the PHAR stub should be generated
     * @param bool            $checkRequirements     Whether the PHAR will check the application requirements before running
     */
    private function __construct(
        ?string $file,
        string $alias,
        string $basePath,
        array $composerJson,
        array $composerLock,
        array $files,
        array $binaryFiles,
        array $compactors,
        ?int $compressionAlgorithm,
        ?int $fileMode,
        string $mainScriptPath,
        string $mainScriptContents,
        MapFile $fileMapper,
        $metadata,
        string $tmpOutputPath,
        string $outputPath,
        ?string $privateKeyPassphrase,
        ?string $privateKeyPath,
        bool $isPrivateKeyPrompt,
        array $processedReplacements,
        ?string $shebang,
        int $signingAlgorithm,
        ?string $stubBannerContents,
        ?string $stubBannerPath,
        ?string $stubPath,
        bool $isInterceptFileFuncs,
        bool $isStubGenerated,
        bool $checkRequirements
    ) {
        Assertion::nullOrInArray(
            $compressionAlgorithm,
            get_phar_compression_algorithms(),
            sprintf(
                'Invalid compression algorithm "%%s", use one of "%s" instead.',
                implode('", "', array_keys(get_phar_compression_algorithms()))
            )
        );

        $this->file = $file;
        $this->alias = $alias;
        $this->basePath = $basePath;
        $this->composerJson = $composerJson;
        $this->composerLock = $composerLock;
        $this->files = $files;
        $this->binaryFiles = $binaryFiles;
        $this->compactors = $compactors;
        $this->compressionAlgorithm = $compressionAlgorithm;
        $this->fileMode = $fileMode;
        $this->mainScriptPath = $mainScriptPath;
        $this->mainScriptContents = $mainScriptContents;
        $this->fileMapper = $fileMapper;
        $this->metadata = $metadata;
        $this->tmpOutputPath = $tmpOutputPath;
        $this->outputPath = $outputPath;
        $this->privateKeyPassphrase = $privateKeyPassphrase;
        $this->privateKeyPath = $privateKeyPath;
        $this->isPrivateKeyPrompt = $isPrivateKeyPrompt;
        $this->processedReplacements = $processedReplacements;
        $this->shebang = $shebang;
        $this->signingAlgorithm = $signingAlgorithm;
        $this->stubBannerContents = $stubBannerContents;
        $this->stubBannerPath = $stubBannerPath;
        $this->stubPath = $stubPath;
        $this->isInterceptFileFuncs = $isInterceptFileFuncs;
        $this->isStubGenerated = $isStubGenerated;
        $this->checkRequirements = $checkRequirements;
    }

    public static function create(?string $file, stdClass $raw): self
    {
        $alias = self::retrieveAlias($raw);

        $basePath = self::retrieveBasePath($file, $raw);

        $composerFiles = self::retrieveComposerFiles($basePath);

        $mainScriptPath = self::retrieveMainScriptPath($raw, $basePath, $composerFiles[0][1]);
        $mainScriptContents = self::retrieveMainScriptContents($mainScriptPath);

        [$tmpOutputPath, $outputPath] = self::retrieveOutputPath($raw, $basePath, $mainScriptPath);

        $composerJson = $composerFiles[0];
        $composerLock = $composerFiles[1];

        $devPackages = ComposerConfiguration::retrieveDevPackages($basePath, $composerJson[1], $composerLock[1]);

        [$excludedPaths, $blacklistFilter] = self::retrieveBlacklistFilter($raw, $basePath, $tmpOutputPath, $outputPath);

        if (self::shouldRetrieveAllFiles($file, $raw)) {
            $filesAggregate = self::retrieveAllFiles($basePath, $mainScriptPath, $blacklistFilter, $excludedPaths, $devPackages);
            $binaryFilesAggregate = [];
        } else {
            $files = self::retrieveFiles($raw, 'files', $basePath, $composerFiles);

            $directories = self::retrieveDirectories($raw, 'directories', $basePath, $blacklistFilter, $excludedPaths);
            $filesFromFinders = self::retrieveFilesFromFinders($raw, 'finder', $basePath, $blacklistFilter, $devPackages);

            $filesAggregate = array_unique(iterator_to_array(chain($files, $directories, ...$filesFromFinders)));

            $binaryFiles = self::retrieveFiles($raw, 'files-bin', $basePath);
            $binaryDirectories = self::retrieveDirectories($raw, 'directories-bin', $basePath, $blacklistFilter, $excludedPaths);
            $binaryFilesFromFinders = self::retrieveFilesFromFinders($raw, 'finder-bin', $basePath, $blacklistFilter, $devPackages);

            $binaryFilesAggregate = array_unique(iterator_to_array(chain($binaryFiles, $binaryDirectories, ...$binaryFilesFromFinders)));
        }

        $compactors = self::retrieveCompactors($raw, $basePath);
        $compressionAlgorithm = self::retrieveCompressionAlgorithm($raw);

        $fileMode = self::retrieveFileMode($raw);

        $map = self::retrieveMap($raw);
        $fileMapper = new MapFile($map);

        $metadata = self::retrieveMetadata($raw);

        $privateKeyPassphrase = self::retrievePrivateKeyPassphrase($raw);
        $privateKeyPath = self::retrievePrivateKeyPath($raw);
        $isPrivateKeyPrompt = self::retrieveIsPrivateKeyPrompt($raw);

        $replacements = self::retrieveReplacements($raw);
        $processedReplacements = self::retrieveProcessedReplacements($replacements, $raw, $file);

        $shebang = self::retrieveShebang($raw);

        $signingAlgorithm = self::retrieveSigningAlgorithm($raw);

        $stubBannerContents = self::retrieveStubBannerContents($raw);
        $stubBannerPath = self::retrieveStubBannerPath($raw, $basePath);

        if (null !== $stubBannerPath) {
            $stubBannerContents = file_contents($stubBannerPath);
        }

        $stubBannerContents = self::normalizeStubBannerContents($stubBannerContents);

        $stubPath = self::retrieveStubPath($raw, $basePath);

        $isInterceptFileFuncs = self::retrieveIsInterceptFileFuncs($raw);
        $isStubGenerated = self::retrieveIsStubGenerated($raw, $stubPath);

        $checkRequirements = self::retrieveCheckRequirements(
            $raw,
            null !== $composerLock[0],
            $isStubGenerated
        );

        return new self(
            $file,
            $alias,
            $basePath,
            $composerJson,
            $composerLock,
            $filesAggregate,
            $binaryFilesAggregate,
            $compactors,
            $compressionAlgorithm,
            $fileMode,
            $mainScriptPath,
            $mainScriptContents,
            $fileMapper,
            $metadata,
            $tmpOutputPath,
            $outputPath,
            $privateKeyPassphrase,
            $privateKeyPath,
            $isPrivateKeyPrompt,
            $processedReplacements,
            $shebang,
            $signingAlgorithm,
            $stubBannerContents,
            $stubBannerPath,
            $stubPath,
            $isInterceptFileFuncs,
            $isStubGenerated,
            $checkRequirements
        );
    }

    public function getFile(): ?string
    {
        return $this->file;
    }

    public function getAlias(): string
    {
        return $this->alias;
    }

    public function getBasePath(): string
    {
        return $this->basePath;
    }

    public function getComposerJson(): ?string
    {
        return $this->composerJson[0];
    }

    public function getComposerJsonDecodedContents(): ?array
    {
        return $this->composerJson[1];
    }

    public function getComposerLock(): ?string
    {
        return $this->composerLock[0];
    }

    public function getComposerLockDecodedContents(): ?array
    {
        return $this->composerLock[1];
    }

    /**
     * @return string[]
     */
    public function getFiles(): array
    {
        return $this->files;
    }

    /**
     * @return string[]
     */
    public function getBinaryFiles(): array
    {
        return $this->binaryFiles;
    }

    /**
     * @return Compactor[] the list of compactors
     */
    public function getCompactors(): array
    {
        return $this->compactors;
    }

    public function getCompressionAlgorithm(): ?int
    {
        return $this->compressionAlgorithm;
    }

    public function getFileMode(): ?int
    {
        return $this->fileMode;
    }

    public function getMainScriptPath(): string
    {
        return $this->mainScriptPath;
    }

    public function getMainScriptContents(): string
    {
        return $this->mainScriptContents;
    }

    public function checkRequirements(): bool
    {
        return $this->checkRequirements;
    }

    public function getTmpOutputPath(): string
    {
        return $this->tmpOutputPath;
    }

    public function getOutputPath(): string
    {
        return $this->outputPath;
    }

    /**
     * @return string[]
     */
    public function getMap(): array
    {
        return $this->fileMapper->getMap();
    }

    public function getFileMapper(): MapFile
    {
        return $this->fileMapper;
    }

    /**
     * @return mixed
     */
    public function getMetadata()
    {
        return $this->metadata;
    }

    public function getPrivateKeyPassphrase(): ?string
    {
        return $this->privateKeyPassphrase;
    }

    public function getPrivateKeyPath(): ?string
    {
        return $this->privateKeyPath;
    }

    public function isPrivateKeyPrompt(): bool
    {
        return $this->isPrivateKeyPrompt;
    }

    public function getProcessedReplacements(): array
    {
        return $this->processedReplacements;
    }

    public function getShebang(): ?string
    {
        return $this->shebang;
    }

    public function getSigningAlgorithm(): int
    {
        return $this->signingAlgorithm;
    }

    public function getStubBannerContents(): ?string
    {
        return $this->stubBannerContents;
    }

    public function getStubBannerPath(): ?string
    {
        return $this->stubBannerPath;
    }

    public function getStubPath(): ?string
    {
        return $this->stubPath;
    }

    public function isInterceptFileFuncs(): bool
    {
        return $this->isInterceptFileFuncs;
    }

    public function isStubGenerated(): bool
    {
        return $this->isStubGenerated;
    }

    private static function retrieveAlias(stdClass $raw): string
    {
        if (false === isset($raw->alias)) {
            return uniqid('box-auto-generated-alias-', false).'.phar';
        }

        $alias = trim($raw->alias);

        Assertion::notEmpty($alias, 'A PHAR alias cannot be empty when provided.');

        return $alias;
    }

    private static function retrieveBasePath(?string $file, stdClass $raw): string
    {
        if (null === $file) {
            return getcwd();
        }

        if (false === isset($raw->{'base-path'})) {
            return realpath(dirname($file));
        }

        $basePath = trim($raw->{'base-path'});

        Assertion::directory(
            $basePath,
            'The base path "%s" is not a directory or does not exist.'
        );

        return realpath($basePath);
    }

    private static function shouldRetrieveAllFiles(?string $file, stdClass $raw): bool
    {
        if (null === $file) {
            return true;
        }

        // TODO: config should be casted into an array: it is easier to do and we need an array in several places now
        $rawConfig = (array) $raw;

        foreach (self::FILES_SETTINGS as $key) {
            if (array_key_exists($key, $rawConfig)) {
                return false;
            }
        }

        return true;
    }

    private static function retrieveBlacklistFilter(stdClass $raw, string $basePath, string ...$excludedPaths): array
    {
        $blacklist = self::retrieveBlacklist($raw, $basePath, ...$excludedPaths);

        $blacklistFilter = function (SplFileInfo $file) use ($blacklist): ?bool {
            if ($file->isLink()) {
                return false;
            }

            if (false === $file->getRealPath()) {
                return false;
            }

            if (in_array($file->getRealPath(), $blacklist, true)) {
                return false;
            }

            return null;
        };

        return [$blacklist, $blacklistFilter];
    }

    /**
     * @param stdClass $raw
     * @param string   $basePath
     * @param string[] $excludedPaths
     *
     * @return string[]
     */
    private static function retrieveBlacklist(stdClass $raw, string $basePath, string ...$excludedPaths): array
    {
        /** @var string[] $blacklist */
        $blacklist = array_merge($excludedPaths, $raw->blacklist ?? []);

        $normalizedBlacklist = [];

        foreach ($blacklist as $file) {
            $normalizedBlacklist[] = self::normalizePath($file, $basePath);
            $normalizedBlacklist[] = canonicalize(make_path_relative(trim($file), $basePath));
        }

        return array_unique($normalizedBlacklist);
    }

    /**
     * @return SplFileInfo[]
     */
    private static function retrieveFiles(stdClass $raw, string $key, string $basePath, array $composerFiles = []): array
    {
        $files = [];

        if (isset($composerFiles[0][0])) {
            $files[] = $composerFiles[0][0];
        }

        if (isset($composerFiles[1][1])) {
            $files[] = $composerFiles[1][0];
        }

        if (false === isset($raw->{$key})) {
            return [];
        }

        $files = array_merge((array) $raw->{$key}, $files);

        Assertion::allString($files);

        $normalizePath = function (string $file) use ($basePath, $key): SplFileInfo {
            $file = self::normalizePath($file, $basePath);

            if (is_link($file)) {
                // TODO: add this to baberlei/assert
                throw new InvalidArgumentException(
                    sprintf(
                        'Cannot add the link "%s": links are not supported.',
                        $file
                    )
                );
            }

            Assertion::file(
                $file,
                sprintf(
                    '"%s" must contain a list of existing files. Could not find "%%s".',
                    $key
                )
            );

            return new SplFileInfo($file);
        };

        return array_map($normalizePath, $files);
    }

    /**
     * @param stdClass $raw
     * @param string   $key             Config property name
     * @param string   $basePath
     * @param Closure  $blacklistFilter
     * @param string[] $excludedPaths
     *
     * @return iterable|SplFileInfo[]
     */
    private static function retrieveDirectories(
        stdClass $raw,
        string $key,
        string $basePath,
        Closure $blacklistFilter,
        array $excludedPaths
    ): iterable {
        $directories = self::retrieveDirectoryPaths($raw, $key, $basePath);

        if ([] !== $directories) {
            $finder = Finder::create()
                ->files()
                ->filter($blacklistFilter)
                ->ignoreVCS(true)
                ->in($directories)
            ;

            foreach ($excludedPaths as $excludedPath) {
                $finder->notPath($excludedPath);
            }

            return $finder;
        }

        return [];
    }

    /**
     * @param stdClass $raw
     * @param string   $key
     * @param string   $basePath
     * @param Closure  $blacklistFilter
     * @param string[] $devPackages
     *
     * @return iterable[]|SplFileInfo[][]
     */
    private static function retrieveFilesFromFinders(
        stdClass $raw,
        string $key,
        string $basePath,
        Closure $blacklistFilter,
        array $devPackages
    ): array {
        if (isset($raw->{$key})) {
            return self::processFinders($raw->{$key}, $basePath, $blacklistFilter, $devPackages);
        }

        return [];
    }

    /**
     * @param array    $findersConfig
     * @param string   $basePath
     * @param Closure  $blacklistFilter
     * @param string[] $devPackages
     *
     * @return Finder[]|SplFileInfo[][]
     */
    private static function processFinders(
        array $findersConfig,
        string $basePath,
        Closure $blacklistFilter,
        array $devPackages
    ): array {
        $processFinderConfig = function (stdClass $config) use ($basePath, $blacklistFilter, $devPackages) {
            return self::processFinder($config, $basePath, $blacklistFilter, $devPackages);
        };

        return array_map($processFinderConfig, $findersConfig);
    }

    /**
     * @param stdClass $config
     * @param string   $basePath
     * @param Closure  $blacklistFilter
     * @param string[] $devPackages
     *
     * @return Finder|SplFileInfo[]
     */
    private static function processFinder(
        stdClass $config,
        string $basePath,
        Closure $blacklistFilter,
        array $devPackages
    ): Finder {
        $finder = Finder::create()
            ->files()
            ->filter($blacklistFilter)
            ->filter(
                function (SplFileInfo $fileInfo) use ($devPackages): bool {
                    foreach ($devPackages as $devPackage) {
                        if ($devPackage === longest_common_base_path([$devPackage, $fileInfo->getRealPath()])) {
                            // File belongs to the dev package
                            return false;
                        }
                    }

                    return true;
                }
            )
            ->ignoreVCS(true)
        ;

        $normalizedConfig = (function (array $config, Finder $finder): array {
            $normalizedConfig = [];

            foreach ($config as $method => $arguments) {
                $method = trim($method);
                $arguments = (array) $arguments;

                Assertion::methodExists(
                    $method,
                    $finder,
                    'The method "Finder::%s" does not exist.'
                );

                $normalizedConfig[$method] = $arguments;
            }

            krsort($normalizedConfig);

            return $normalizedConfig;
        })((array) $config, $finder);

        $createNormalizedDirectories = function (string $directory) use ($basePath): ?string {
            $directory = self::normalizePath($directory, $basePath);

            if (is_link($directory)) {
                // TODO: add this to baberlei/assert
                throw new InvalidArgumentException(
                    sprintf(
                        'Cannot append the link "%s" to the Finder: links are not supported.',
                        $directory
                    )
                );
            }

            Assertion::directory($directory);

            return $directory;
        };

        $normalizeFileOrDirectory = function (string &$fileOrDirectory) use ($basePath): void {
            $fileOrDirectory = self::normalizePath($fileOrDirectory, $basePath);

            if (is_link($fileOrDirectory)) {
                // TODO: add this to baberlei/assert
                throw new InvalidArgumentException(
                    sprintf(
                        'Cannot append the link "%s" to the Finder: links are not supported.',
                        $fileOrDirectory
                    )
                );
            }

            // TODO: add this to baberlei/assert
            if (false === file_exists($fileOrDirectory)) {
                throw new InvalidArgumentException(
                    sprintf(
                        'Path "%s" was expected to be a file or directory. It may be a symlink (which are unsupported).',
                        $fileOrDirectory
                    )
                );
            }

            // TODO: add fileExists (as file or directory) to Assert
            if (false === is_file($fileOrDirectory)) {
                Assertion::directory($fileOrDirectory);
            } else {
                Assertion::file($fileOrDirectory);
            }
        };

        foreach ($normalizedConfig as $method => $arguments) {
            if ('in' === $method) {
                $normalizedConfig[$method] = $arguments = array_map($createNormalizedDirectories, $arguments);
            }

            if ('exclude' === $method) {
                $arguments = array_unique(array_map('trim', $arguments));
            }

            if ('append' === $method) {
                array_walk($arguments, $normalizeFileOrDirectory);

                $arguments = [$arguments];
            }

            foreach ($arguments as $argument) {
                $finder->$method($argument);
            }
        }

        return $finder;
    }

    /**
     * @param string   $basePath
     * @param string   $mainScriptPath
     * @param Closure  $blacklistFilter
     * @param string[] $excludedPaths
     * @param string[] $devPackages
     *
     * @return SplFileInfo[]
     */
    private static function retrieveAllFiles(
        string $basePath,
        string $mainScriptPath,
        Closure $blacklistFilter,
        array $excludedPaths,
        array $devPackages
    ): array {
        $relativeDevPackages = array_map(
            function (string $packagePath) use ($basePath): string {
                return make_path_relative($packagePath, $basePath);
            },
            $devPackages
        );

        $finder = Finder::create()
            ->files()
            ->in($basePath)
            ->notPath(make_path_relative($mainScriptPath, $basePath))
            ->filter($blacklistFilter)
            ->exclude($relativeDevPackages)
            ->ignoreVCS(true)
        ;

        $excludedPaths = array_unique(
            array_filter(
                array_map(
                    function (string $path) use ($basePath): string {
                        return make_path_relative($path, $basePath);
                    },
                    $excludedPaths
                ),
                function (string $path): bool {
                    return '..' !== substr($path, 0, 2);
                }
            )
        );

        foreach ($excludedPaths as $excludedPath) {
            $finder->notPath($excludedPath);
        }

        return array_unique(
            toArray(
                map(
                    method('getRealPath'),
                    $finder
                )
            )
        );
    }

    /**
     * @param stdClass $raw
     * @param string   $key      Config property name
     * @param string   $basePath
     *
     * @return string[]
     */
    private static function retrieveDirectoryPaths(stdClass $raw, string $key, string $basePath): array
    {
        if (false === isset($raw->{$key})) {
            return [];
        }

        $directories = $raw->{$key};

        $normalizeDirectory = function (string $directory) use ($basePath, $key): string {
            $directory = self::normalizePath($directory, $basePath);

            if (is_link($directory)) {
                // TODO: add this to baberlei/assert
                throw new InvalidArgumentException(
                    sprintf(
                        'Cannot add the link "%s": links are not supported.',
                        $directory
                    )
                );
            }

            Assertion::directory(
                $directory,
                sprintf(
                    '"%s" must contain a list of existing directories. Could not find "%%s".',
                    $key
                )
            );

            return $directory;
        };

        return array_map($normalizeDirectory, $directories);
    }

    private static function normalizePath(string $file, string $basePath): string
    {
        return make_path_absolute(trim($file), $basePath);
    }

    /**
     * @return Compactor[]
     */
    private static function retrieveCompactors(stdClass $raw, string $basePath): array
    {
        if (false === isset($raw->compactors)) {
            return [];
        }

        $compactorClasses = array_unique((array) $raw->compactors);

        return array_map(
            function (string $class) use ($raw, $basePath): Compactor {
                Assertion::classExists($class, 'The compactor class "%s" does not exist.');
                Assertion::implementsInterface($class, Compactor::class, 'The class "%s" is not a compactor class.');

                if (Php::class === $class || LegacyPhp::class === $class) {
                    return self::createPhpCompactor($raw);
                }

                if (PhpScoperCompactor::class === $class) {
                    $phpScoperConfig = self::retrievePhpScoperConfig($raw, $basePath);

                    return new PhpScoperCompactor(
                        new SimpleScoper(
                            create_scoper(),
                            uniqid('_HumbugBox', false),
                            $phpScoperConfig->getWhitelist(),
                            $phpScoperConfig->getPatchers()
                        )
                    );
                }

                return new $class();
            },
            $compactorClasses
        );
    }

    private static function retrieveCompressionAlgorithm(stdClass $raw): ?int
    {
        if (false === isset($raw->compression)) {
            return null;
        }

        $knownAlgorithmNames = array_keys(get_phar_compression_algorithms());

        Assertion::inArray(
            $raw->compression,
            $knownAlgorithmNames,
            sprintf(
                'Invalid compression algorithm "%%s", use one of "%s" instead.',
                implode('", "', $knownAlgorithmNames)
            )
        );

        $value = get_phar_compression_algorithms()[$raw->compression];

        // Phar::NONE is not valid for compressFiles()
        if (Phar::NONE === $value) {
            return null;
        }

        return $value;
    }

    private static function retrieveFileMode(stdClass $raw): ?int
    {
        if (isset($raw->chmod)) {
            return intval($raw->chmod, 8);
        }

        return null;
    }

    private static function retrieveMainScriptPath(stdClass $raw, string $basePath, ?array $decodedJsonContents): string
    {
        if (isset($raw->main)) {
            $main = $raw->main;
        } else {
            if (null === $decodedJsonContents
                || false === array_key_exists('bin', $decodedJsonContents)
                || false === $main = current($decodedJsonContents['bin'])
            ) {
                $main = self::DEFAULT_MAIN_SCRIPT;
            }
        }

        return self::normalizePath($main, $basePath);
    }

    private static function retrieveMainScriptContents(string $mainScriptPath): string
    {
        $contents = file_contents($mainScriptPath);

        // Remove the shebang line: the shebang line in a PHAR should be located in the stub file which is the real
        // PHAR entry point file.
        return preg_replace('/^#!.*\s*/', '', $contents);
    }

    private static function retrieveComposerFiles(string $basePath): array
    {
        $retrieveFileAndContents = function (string $file): array {
            $json = new Json();

            if (false === file_exists($file) || false === is_file($file) || false === is_readable($file)) {
                return [null, null];
            }

            try {
                $contents = $json->decodeFile($file, true);
            } catch (ParsingException $exception) {
                throw new InvalidArgumentException(
                    sprintf(
                        'Expected the file "%s" to be a valid composer.json file but an error has been found: %s',
                        $file,
                        $exception->getMessage()
                    ),
                    0,
                    $exception
                );
            }

            return [$file, $contents];
        };

        [$composerJson, $composerJsonContents] = $retrieveFileAndContents(canonicalize($basePath.'/composer.json'));
        [$composerLock, $composerLockContents] = $retrieveFileAndContents(canonicalize($basePath.'/composer.lock'));

        return [
            [$composerJson, $composerJsonContents],
            [$composerLock, $composerLockContents],
        ];
    }

    /**
     * @return string[][]
     */
    private static function retrieveMap(stdClass $raw): array
    {
        if (false === isset($raw->map)) {
            return [];
        }

        $map = [];

        foreach ((array) $raw->map as $item) {
            $processed = [];

            foreach ($item as $match => $replace) {
                $processed[canonicalize(trim($match))] = canonicalize(trim($replace));
            }

            if (isset($processed['_empty_'])) {
                $processed[''] = $processed['_empty_'];

                unset($processed['_empty_']);
            }

            $map[] = $processed;
        }

        return $map;
    }

    /**
     * @return mixed
     */
    private static function retrieveMetadata(stdClass $raw)
    {
        if (isset($raw->metadata)) {
            if (is_object($raw->metadata)) {
                return (array) $raw->metadata;
            }

            return $raw->metadata;
        }

        return null;
    }

    /**
     * @return string[] The first element is the temporary output path and the second the real one
     */
    private static function retrieveOutputPath(stdClass $raw, string $basePath, string $mainScriptPath): array
    {
        if (isset($raw->output)) {
            $path = $raw->output;
        } else {
            if (1 === preg_match('/^(?<main>.*?)(?:\.[\p{L}\d]+)?$/', $mainScriptPath, $matches)) {
                $path = $matches['main'].'.phar';
            } else {
                // Last resort, should not happen
                $path = self::DEFAULT_ALIAS;
            }
        }

        $tmp = $real = self::normalizePath($path, $basePath);

        if ('.phar' !== substr($real, -5)) {
            $tmp .= '.phar';
        }

        return [$tmp, $real];
    }

    private static function retrievePrivateKeyPassphrase(stdClass $raw): ?string
    {
        // TODO: add check to not allow this setting without the private key path
        if (isset($raw->{'key-pass'})
            && is_string($raw->{'key-pass'})
        ) {
            return $raw->{'key-pass'};
        }

        return null;
    }

    private static function retrievePrivateKeyPath(stdClass $raw): ?string
    {
        // TODO: If passed need to check its existence
        // Also need

        if (isset($raw->key)) {
            return $raw->key;
        }

        return null;
    }

    private static function retrieveReplacements(stdClass $raw): array
    {
        // TODO: add exmample in the doc
        // Add checks against the values
        if (isset($raw->replacements)) {
            return (array) $raw->replacements;
        }

        return [];
    }

    private static function retrieveProcessedReplacements(
        array $replacements,
        stdClass $raw,
        ?string $file
    ): array {
        if (null === $file) {
            return [];
        }

        if (null !== ($git = self::retrieveGitHashPlaceholder($raw))) {
            $replacements[$git] = self::retrieveGitHash($file);
        }

        if (null !== ($git = self::retrieveGitShortHashPlaceholder($raw))) {
            $replacements[$git] = self::retrieveGitHash($file, true);
        }

        if (null !== ($git = self::retrieveGitTagPlaceholder($raw))) {
            $replacements[$git] = self::retrieveGitTag($file);
        }

        if (null !== ($git = self::retrieveGitVersionPlaceholder($raw))) {
            $replacements[$git] = self::retrieveGitVersion($file);
        }

        if (null !== ($date = self::retrieveDatetimeNowPlaceHolder($raw))) {
            $replacements[$date] = self::retrieveDatetimeNow(
                self::retrieveDatetimeFormat($raw)
            );
        }

        $sigil = self::retrieveReplacementSigil($raw);

        foreach ($replacements as $key => $value) {
            unset($replacements[$key]);
            $replacements["$sigil$key$sigil"] = $value;
        }

        return $replacements;
    }

    private static function retrieveGitHashPlaceholder(stdClass $raw): ?string
    {
        if (isset($raw->{'git-commit'})) {
            return $raw->{'git-commit'};
        }

        return null;
    }

    /**
     * @param string $file
     * @param bool   $short Use the short version
     *
     * @return string the commit hash
     */
    private static function retrieveGitHash(string $file, bool $short = false): string
    {
        return self::runGitCommand(
            sprintf(
                'git log --pretty="%s" -n1 HEAD',
                $short ? '%h' : '%H'
            ),
            $file
        );
    }

    private static function retrieveGitShortHashPlaceholder(stdClass $raw): ?string
    {
        if (isset($raw->{'git-commit-short'})) {
            return $raw->{'git-commit-short'};
        }

        return null;
    }

    private static function retrieveGitTagPlaceholder(stdClass $raw): ?string
    {
        if (isset($raw->{'git-tag'})) {
            return $raw->{'git-tag'};
        }

        return null;
    }

    private static function retrieveGitTag(string $file): ?string
    {
        return self::runGitCommand('git describe --tags HEAD', $file);
    }

    private static function retrieveGitVersionPlaceholder(stdClass $raw): ?string
    {
        if (isset($raw->{'git-version'})) {
            return $raw->{'git-version'};
        }

        return null;
    }

    private static function retrieveGitVersion(string $file): ?string
    {
        // TODO: check if is still relevant as IMO we are better off using OcramiusVersionPackage
        // to avoid messing around with that

        try {
            return self::retrieveGitTag($file);
        } catch (RuntimeException $exception) {
            try {
                return self::retrieveGitHash($file, true);
            } catch (RuntimeException $exception) {
                throw new RuntimeException(
                    sprintf(
                        'The tag or commit hash could not be retrieved from "%s": %s',
                        dirname($file),
                        $exception->getMessage()
                    ),
                    0,
                    $exception
                );
            }
        }
    }

    private static function retrieveDatetimeNowPlaceHolder(stdClass $raw): ?string
    {
        // TODO: double check why this is done and how it is used it's not completely clear to me.
        // Also make sure the documentation is up to date after.
        // Instead of having two sistinct doc entries for `datetime` and `datetime-format`, it would
        // be better to have only one element IMO like:
        //
        // "datetime": {
        //   "value": "val",
        //   "format": "Y-m-d"
        // }
        //
        // Also add a check that one cannot be provided without the other. Or maybe it should? I guess
        // if the datetime format is the default one it's ok; but in any case the format should not
        // be added without the datetime value...

        if (isset($raw->{'datetime'})) {
            return $raw->{'datetime'};
        }

        return null;
    }

    private static function retrieveDatetimeNow(string $format)
    {
        $now = new DateTimeImmutable('now');

        $datetime = $now->format($format);

        if (!$datetime) {
            throw new InvalidArgumentException(
                sprintf(
                    '""%s" is not a valid PHP date format',
                    $format
                )
            );
        }

        return $datetime;
    }

    private static function retrieveDatetimeFormat(stdClass $raw): string
    {
        if (isset($raw->{'datetime_format'})) {
            return $raw->{'datetime_format'};
        }

        return self::DEFAULT_DATETIME_FORMAT;
    }

    private static function retrieveReplacementSigil(stdClass $raw)
    {
        if (isset($raw->{'replacement-sigil'})) {
            return $raw->{'replacement-sigil'};
        }

        return self::DEFAULT_REPLACEMENT_SIGIL;
    }

    private static function retrieveShebang(stdClass $raw): ?string
    {
        if (false === array_key_exists('shebang', (array) $raw)) {
            return self::DEFAULT_SHEBANG;
        }

        if (null === $raw->shebang) {
            return null;
        }

        $shebang = trim($raw->shebang);

        Assertion::notEmpty($shebang, 'The shebang should not be empty.');
        Assertion::true(
            '#!' === substr($shebang, 0, 2),
            sprintf(
                'The shebang line must start with "#!". Got "%s" instead',
                $shebang
            )
        );

        return $shebang;
    }

    private static function retrieveSigningAlgorithm(stdClass $raw): int
    {
        // TODO: trigger warning: if no signing algorithm is given provided we are not in dev mode
        // TODO: trigger a warning if the signing algorithm used is weak
        // TODO: no longer accept strings & document BC break
        if (false === isset($raw->algorithm)) {
            return Phar::SHA1;
        }

        if (false === defined('Phar::'.$raw->algorithm)) {
            throw new InvalidArgumentException(
                sprintf(
                    'The signing algorithm "%s" is not supported.',
                    $raw->algorithm
                )
            );
        }

        return constant('Phar::'.$raw->algorithm);
    }

    private static function retrieveStubBannerContents(stdClass $raw): ?string
    {
        if (false === array_key_exists('banner', (array) $raw)) {
            return self::DEFAULT_BANNER;
        }

        if (null === $raw->banner) {
            return null;
        }

        $banner = $raw->banner;

        if (is_array($banner)) {
            $banner = implode("\n", $banner);
        }

        return $banner;
    }

    private static function retrieveStubBannerPath(stdClass $raw, string $basePath): ?string
    {
        if (false === isset($raw->{'banner-file'})) {
            return null;
        }

        $bannerFile = make_path_absolute($raw->{'banner-file'}, $basePath);

        Assertion::file($bannerFile);

        return $bannerFile;
    }

    private static function normalizeStubBannerContents(?string $contents): ?string
    {
        if (null === $contents) {
            return null;
        }

        $banner = explode("\n", $contents);
        $banner = array_map('trim', $banner);

        return implode("\n", $banner);
    }

    private static function retrieveStubPath(stdClass $raw, string $basePath): ?string
    {
        if (isset($raw->stub) && is_string($raw->stub)) {
            $stubPath = make_path_absolute($raw->stub, $basePath);

            Assertion::file($stubPath);

            return $stubPath;
        }

        return null;
    }

    private static function retrieveIsInterceptFileFuncs(stdClass $raw): bool
    {
        if (isset($raw->intercept)) {
            return $raw->intercept;
        }

        return false;
    }

    private static function retrieveIsPrivateKeyPrompt(stdClass $raw): bool
    {
        return isset($raw->{'key-pass'}) && (true === $raw->{'key-pass'});
    }

    private static function retrieveIsStubGenerated(stdClass $raw, ?string $stubPath): bool
    {
        return null === $stubPath && (false === isset($raw->stub) || false !== $raw->stub);
    }

    private static function retrieveCheckRequirements(stdClass $raw, bool $hasComposerLock, bool $generateStub): bool
    {
        // TODO: emit warning when stub is not generated and check requirements is explicitly set to true
        // TODO: emit warning when no composer lock is found but check requirements is explicitely set to true
        if (false === $hasComposerLock) {
            return false;
        }

        return $raw->{'check-requirements'} ?? true;
    }

    private static function retrievePhpScoperConfig(stdClass $raw, string $basePath): PhpScoperConfiguration
    {
        if (!isset($raw->{'php-scoper'})) {
            $configFilePath = make_path_absolute(self::PHP_SCOPER_CONFIG, $basePath);

            return file_exists($configFilePath)
                ? PhpScoperConfiguration::load($configFilePath)
                : PhpScoperConfiguration::load()
             ;
        }

        $configFile = $raw->phpScoper;

        Assertion::string($configFile);

        $configFilePath = make_path_absolute($configFile, $basePath);

        Assertion::file($configFilePath);
        Assertion::readable($configFilePath);

        return PhpScoperConfiguration::load($configFilePath);
    }

    /**
     * Runs a Git command on the repository.
     *
     * @param string $command the command
     *
     * @return string the trimmed output from the command
     */
    private static function runGitCommand(string $command, string $file): string
    {
        $path = dirname($file);

        $process = new Process($command, $path);

        if (0 === $process->run()) {
            return trim($process->getOutput());
        }

        throw new RuntimeException(
            sprintf(
                'The tag or commit hash could not be retrieved from "%s": %s',
                $path,
                $process->getErrorOutput()
            )
        );
    }

    private static function createPhpCompactor(stdClass $raw): Compactor
    {
        // TODO: false === not set; check & add test/doc
        $tokenizer = new Tokenizer();

        if (false === empty($raw->annotations) && isset($raw->annotations->ignore)) {
            $tokenizer->ignore(
                (array) $raw->annotations->ignore
            );
        }

        return new Php($tokenizer);
    }
}

<?php

declare(strict_types=1);

/*
 * This file is part of the box project.
 *
 * (c) Kevin Herrera <kevin@herrera.io>
 *     Th√©o Fidry <theo.fidry@gmail.com>
 *
 * This source file is subject to the MIT license that is bundled
 * with this source code in the file LICENSE.
 */

namespace KevinGH\Box;

use Assert\Assertion;
use Herrera\Annotations\Tokenizer;
use KevinGH\Box\Compactor\Php;

/**
 * Generates a new PHP bootstrap loader stub for a PHAR.
 */
final class StubGenerator
{
    /**
     * @var string[] the list of server variables that are allowed to be modified
     */
    private const ALLOWED_MUNG = [
        'PHP_SELF',
        'REQUEST_URI',
        'SCRIPT_FILENAME',
        'SCRIPT_NAME',
    ];

    /**
     * @var string The alias to be used in "phar://" URLs
     */
    private $alias = '';

    /**
     * @var null|string The top header comment banner text
     */
    private $banner = <<<'BANNER'

Generated by Box.

@link https://github.com/humbug/box

BANNER;

    /**
     * @var bool Embed the Extract class in the stub?
     */
    private $extract = false;

    /**
     * @var array The processed extract code
     */
    private $extractCode = [];

    /**
     * @var bool Force the use of the Extract class?
     */
    private $extractForce = false;

    /**
     * @var null|string The location within the PHAR of index script
     */
    private $index;

    /**
     * @var bool Use the Phar::interceptFileFuncs() method?
     */
    private $intercept = false;

    /**
     * @var array The map for file extensions and their mimetypes
     */
    private $mimetypes = [];

    /**
     * The list of server variables to modify.
     *
     * @var array
     */
    private $mung = [];

    /**
     * @var null|string The location of the script to run when a file is not found
     */
    private $notFound;

    /**
     * @var null|string The rewrite function name
     */
    private $rewrite;

    /**
     * @var string The shebang line
     */
    private $shebang = '#!/usr/bin/env php';

    /**
     * Use Phar::webPhar() instead of Phar::mapPhar()?
     *
     * @var bool
     */
    private $web = false;

    /**
     * Creates a new instance of the stub generator.
     *
     * @return StubGenerator the stub generator
     */
    public static function create()
    {
        return new static();
    }

    /**
     * @return string The stub
     */
    public function generate(): string
    {
        $stub = [];

        if ('' !== $this->shebang) {
            $stub[] = $this->shebang;
        }

        $stub[] = '<?php';

        if (null !== $this->banner) {
            $stub[] = $this->getBanner();
        }

        if ($this->extract) {
            $stub[] = implode("\n", $this->extractCode['constants']);

            if ($this->extractForce) {
                $stub = array_merge($stub, $this->getExtractSections());
            }
        }

        $stub = array_merge($stub, $this->getPharSections());

        if ($this->extract) {
            if ($this->extractForce) {
                if ($this->index && !$this->web) {
                    $stub[] = "require \"\$dir/{$this->index}\";";
                }
            } else {
                end($stub);

                $stub[key($stub)] .= ' else {';

                $stub = array_merge($stub, $this->getExtractSections());

                if ($this->index) {
                    $stub[] = "require \"\$dir/{$this->index}\";";
                }

                $stub[] = '}';
            }

            $stub[] = implode("\n", $this->extractCode['class']);
        }

        $stub[] = '__HALT_COMPILER();';

        return implode("\n", $stub);
    }

    public function alias(string $alias): self
    {
        $this->alias = $alias;

        return $this;
    }

    public function banner(?string $banner): self
    {
        $this->banner = $banner;

        return $this;
    }

    public function extract(bool $extract, bool $force = false): self
    {
        $this->extract = $extract;
        $this->extractForce = $force;

        if ($extract) {
            $this->extractCode = [
                'constants' => [],
                'class' => [],
            ];

            $compactor = new Php(new Tokenizer());

            $file = __DIR__.'/Box_Extract.php';

            $code = file_get_contents($file);
            $code = $compactor->compact($file, $code);
            $code = preg_replace('/\n+/', "\n", $code);
            $code = explode("\n", $code);
            $code = array_slice($code, 2);

            foreach ($code as $i => $line) {
                if ((0 === strpos($line, 'use'))
                    && (false === strpos($line, '\\'))
                ) {
                    unset($code[$i]);
                } elseif (0 === strpos($line, 'define')) {
                    $this->extractCode['constants'][] = $line;
                } else {
                    $this->extractCode['class'][] = $line;
                }
            }
        }

        return $this;
    }

    public function index(?string $index): self
    {
        $this->index = $index;

        return $this;
    }

    public function intercept(bool $intercept): self
    {
        $this->intercept = $intercept;

        return $this;
    }

    public function mimetypes(array $mimetypes): self
    {
        $this->mimetypes = $mimetypes;

        return $this;
    }

    public function mung(array $list): self
    {
        Assertion::allInArray(
            $list,
            self::ALLOWED_MUNG,
            'The $_SERVER variable "%s" is not allowed.'
        );

        $this->mung = $list;

        return $this;
    }

    public function notFound(?string $script): self
    {
        $this->notFound = $script;

        return $this;
    }

    public function rewrite(?string $function): self
    {
        $this->rewrite = $function;

        return $this;
    }

    public function shebang(string $shebang): self
    {
        $this->shebang = $shebang;

        return $this;
    }

    public function web(bool $web): self
    {
        $this->web = $web;

        return $this;
    }

    /**
     * Escapes an argument so it can be written as a string in a call.
     *
     * @param string $arg
     * @param string $quote
     *
     * @return string The escaped argument
     */
    private function arg(string $arg, string $quote = "'"): string
    {
        return $quote.addcslashes($arg, $quote).$quote;
    }

    /**
     * @return string The alias map
     */
    private function getAlias(): string
    {
        $stub = '';
        $prefix = '';

        if ($this->extractForce) {
            $prefix = '$dir/';
        }

        if ($this->web) {
            $stub .= 'Phar::webPhar('.$this->arg($this->alias);

            if ($this->index) {
                $stub .= ', '.$this->arg($prefix.$this->index, '"');

                if ($this->notFound) {
                    $stub .= ', '.$this->arg($prefix.$this->notFound, '"');

                    if ($this->mimetypes) {
                        $stub .= ', '.var_export(
                            $this->mimetypes,
                            true
                        );

                        if ($this->rewrite) {
                            $stub .= ', '.$this->arg($this->rewrite);
                        }
                    }
                }
            }

            $stub .= ');';
        } else {
            $stub .= 'Phar::mapPhar('.$this->arg($this->alias).');';
        }

        return $stub;
    }

    /**
     * @return string the processed banner
     */
    private function getBanner(): string
    {
        // TODO: review how the banner is processed. Right now the doc says it can be a string
        // already enclosed in comments and if not it will be enclosed automatically.
        //
        // What needs to be done here?
        // - Test with a simple one liner banner
        // - Test with a banner enclosed in comments
        // - Test with a banner enclosed in phpdoc
        //
        // Then comes the question of multiline banners: I guess it works if contains `\n`?
        // Need tests for that anyway.
        //
        // Maybe a more user-friendly way to deal with multi-line banners would be to allow
        // an array of strings instead of just a string.
        //

        $banner = "/**\n * ";
        $banner .= str_replace(
            " \n",
            "\n",
            str_replace("\n", "\n * ", $this->banner)
        );

        $banner .= "\n */";

        return $banner;
    }

    /**
     * @return string[] The self extracting sections of the stub
     */
    private function getExtractSections(): array
    {
        return [
            '$extract = new Extract(__FILE__, Extract::findStubLength(__FILE__));',
            '$dir = $extract->go();',
            'set_include_path($dir . PATH_SEPARATOR . get_include_path());',
        ];
    }

    /**
     * @return string[] The sections of the stub that use the PHAR class
     */
    private function getPharSections(): array
    {
        $stub = [
            'if (class_exists(\'Phar\')) {',
            $this->getAlias(),
        ];

        if ($this->intercept) {
            $stub[] = 'Phar::interceptFileFuncs();';
        }

        if ($this->mung) {
            $stub[] = 'Phar::mungServer('.var_export($this->mung, true).');';
        }

        if ($this->index && !$this->web && !$this->extractForce) {
            $stub[] = "require 'phar://' . __FILE__ . '/{$this->index}';";
        }

        $stub[] = '}';

        return $stub;
    }
}
